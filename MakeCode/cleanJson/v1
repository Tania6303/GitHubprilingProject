// ========================================
// גרסה: 1.1 | עדכון אחרון: 22/12/25
// מנקה JSON + יוצר סיכום חשבוניות + פורמט תאריכים
// ========================================

// קריאת קלט
let invoicesJson = input.invoices_json;

// המרה למערך אם נדרש
let invoices = [];
try {
  if (typeof invoicesJson === 'string') {
    invoices = JSON.parse(invoicesJson);
  } else if (Buffer.isBuffer(invoicesJson)) {
    invoices = JSON.parse(invoicesJson.toString('utf8'));
  } else if (Array.isArray(invoicesJson)) {
    invoices = invoicesJson;
  } else if (typeof invoicesJson === 'object') {
    invoices = [invoicesJson];
  } else {
    throw new Error('פורמט קלט לא תקין');
  }
} catch (err) {
  return {
    status: 'error',
    message: 'שגיאה בקריאת הקלט: ' + err.message
  };
}

// ========================================
// פונקציה: בדיקה אם ערך ריק
// ========================================
function isEmpty(value) {
  if (value === null || value === undefined) {
    return true;
  }
  if (value === '') {
    return true;
  }
  if (value === 0) {
    return true;
  }
  if (Array.isArray(value) && value.length === 0) {
    return true;
  }
  return false;
}

// ========================================
// פונקציה: פורמט תאריך למבנה DD/MM/YY או DD/MM/YY hh:mm
// ========================================
function formatDate(value) {
  if (typeof value !== 'string') {
    return value;
  }

  // בדיקה אם זה נראה כמו תאריך
  let day, month, year, hours, minutes;

  // פורמט ISO עם שעה: 2025-12-01T11:33:00+02:00 או 2024-01-15T10:30:00Z
  const isoWithTimeMatch = value.match(/^(\d{4})-(\d{2})-(\d{2})T(\d{2}):(\d{2}):\d{2}([+-]\d{2}:\d{2}|Z)?$/);
  if (isoWithTimeMatch) {
    year = isoWithTimeMatch[1];
    month = isoWithTimeMatch[2];
    day = isoWithTimeMatch[3];
    hours = isoWithTimeMatch[4];
    minutes = isoWithTimeMatch[5];
    const shortYear = year.slice(-2);
    // אם השעה היא 00:00, מחזירים רק תאריך ללא שעה
    if (hours === '00' && minutes === '00') {
      return `${day}/${month}/${shortYear}`;
    }
    // פורמט עם שעה: DD/MM/YY hh:mm
    return `${day}/${month}/${shortYear} ${hours}:${minutes}`;
  }

  // פורמט ISO ללא שעה: 2024-01-15
  const isoMatch = value.match(/^(\d{4})-(\d{2})-(\d{2})$/);
  if (isoMatch) {
    year = isoMatch[1];
    month = isoMatch[2];
    day = isoMatch[3];
  }

  // פורמט: YYYY/MM/DD
  const slashYMD = value.match(/^(\d{4})\/(\d{2})\/(\d{2})$/);
  if (slashYMD) {
    year = slashYMD[1];
    month = slashYMD[2];
    day = slashYMD[3];
  }

  // פורמט: DD-MM-YYYY או DD.MM.YYYY
  const dmy = value.match(/^(\d{2})[-.](\d{2})[-.](\d{4})$/);
  if (dmy) {
    day = dmy[1];
    month = dmy[2];
    year = dmy[3];
  }

  // פורמט: MM/DD/YYYY (אמריקאי) - נזהה לפי ערכים
  const mdySlash = value.match(/^(\d{2})\/(\d{2})\/(\d{4})$/);
  if (mdySlash) {
    const first = parseInt(mdySlash[1]);
    const second = parseInt(mdySlash[2]);
    // אם הערך הראשון גדול מ-12, זה יום (DD/MM/YYYY)
    if (first > 12) {
      day = mdySlash[1];
      month = mdySlash[2];
      year = mdySlash[3];
    } else if (second > 12) {
      // אם השני גדול מ-12, זה MM/DD/YYYY
      month = mdySlash[1];
      day = mdySlash[2];
      year = mdySlash[3];
    } else {
      // ברירת מחדל: מניחים DD/MM/YYYY
      day = mdySlash[1];
      month = mdySlash[2];
      year = mdySlash[3];
    }
  }

  // פורמט: DD/MM/YY (כבר בפורמט הנכון, רק מוודאים)
  const dmyShort = value.match(/^(\d{2})\/(\d{2})\/(\d{2})$/);
  if (dmyShort) {
    return value; // כבר בפורמט הנכון
  }

  // אם מצאנו תאריך תקין, נחזיר בפורמט DD/MM/YY
  if (day && month && year) {
    // קיצור השנה לשתי ספרות אחרונות
    const shortYear = year.slice(-2);
    return `${day}/${month}/${shortYear}`;
  }

  // אם לא זוהה כתאריך, נחזיר את הערך המקורי
  return value;
}

// ========================================
// פונקציה: ניקוי אובייקט רקורסיבית עם פורמט תאריכים
// ========================================
function cleanObject(obj) {
  if (isEmpty(obj)) {
    return null;
  }

  if (Array.isArray(obj)) {
    const cleaned = obj
      .map(item => cleanObject(item))
      .filter(item => item !== null);
    return cleaned.length > 0 ? cleaned : null;
  }

  if (typeof obj === 'object') {
    const cleaned = {};

    for (const key in obj) {
      if (obj.hasOwnProperty(key)) {
        const value = obj[key];

        if (!isEmpty(value)) {
          const cleanedValue = cleanObject(value);

          if (cleanedValue !== null) {
            // הפעלת פורמט תאריך על ערכים מסוג string
            if (typeof cleanedValue === 'string') {
              cleaned[key] = formatDate(cleanedValue);
            } else {
              cleaned[key] = cleanedValue;
            }
          }
        }
      }
    }

    return Object.keys(cleaned).length > 0 ? cleaned : null;
  }

  // הפעלת פורמט תאריך על ערכים פרימיטיביים (string)
  if (typeof obj === 'string') {
    return formatDate(obj);
  }

  return obj;
}

// ========================================
// ניקוי כל החשבוניות
// ========================================
let cleanedInvoices = [];

try {
  cleanedInvoices = invoices
    .map(invoice => cleanObject(invoice))
    .filter(invoice => invoice !== null);
} catch (err) {
  return {
    status: 'error',
    message: 'שגיאה בניקוי: ' + err.message
  };
}

// ========================================
// יצירת סיכום חשבוניות
// ========================================
let invoicesSummary = [];

try {
  invoicesSummary = cleanedInvoices.map(invoice => ({
    SUPNAME: invoice.SUPNAME || '',
    IVNUM: invoice.IVNUM || '',
    BOOKNUM: invoice.BOOKNUM || '',
    DEBIT: invoice.DEBIT || ''
  }));
} catch (err) {
  return {
    status: 'error',
    message: 'שגיאה ביצירת סיכום: ' + err.message
  };
}

// ========================================
// החזרת תוצאה
// ========================================
return {
  status: 'success',
  original_count: invoices.length,
  cleaned_count: cleanedInvoices.length,
  cleaned_json: cleanedInvoices,
  invoices_summary: invoicesSummary
};

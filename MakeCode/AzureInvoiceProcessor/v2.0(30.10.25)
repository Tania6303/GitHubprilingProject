// ================================================================
// Azure Invoice Processor v2.5 - FIX: Extract formatted numbers (prevent splits)
// ×¢×•×“×›×Ÿ: 9 × ×•×‘××‘×¨ 2025 19:12
// ================================================================
//
// âš ï¸ ×—×•×‘×”! ×œ×¤× ×™ ×›×œ ×ª×™×§×•×Ÿ - ×‘×“×•×§ ×‘×§×•×“×™× ×”×‘××™×:
// - Processing Invoice (v4.2-COMPLETE.js)
// - Production Invoice (v1.0-production.js)
//
// ğŸ“ ×§×‘×¦×™ ×‘×“×™×§×”:
// - MakeCode/AzureInvoiceProcessor/EXEMPTS/input.txt + output.txt
// - MakeCode/Processing Invoice/QA/
// - MakeCode/Production Invoice/QA/
//
// ğŸ“– ×ª×™×¢×•×“ ××¤×•×¨×˜ ×•×”×™×¡×˜×•×¨×™×”: ×¨××” README.md
// ================================================================

const contentLong = input.contentLong || input.contentlong || '';
const pagesInput = input.pages || [];
const tablesInput = input.tables || [];
const documentsInput = input.documents || [];
const modelId = input.modelId || '';

const azureJsonInput = {
    content: contentLong,
    pages: pagesInput,
    tables: tablesInput,
    documents: documentsInput,
    modelId: modelId
};

function processAzureInvoice(azureInput) {
    const analyzeResult = loadAnalyzeResult(azureInput);

    const rawContent = analyzeResult.content || '';
    const tables = analyzeResult.tables || [];
    const documents = analyzeResult.documents || [];

    const result = {
        docType: 'invoice',
        fields: {}
    };

    if (documents.length > 0 && documents[0].fields) {
        extractAzureFields(documents[0].fields, result.fields);
    }

    // ××—×“ ×¤×¨×™×˜×™× ×›×¤×•×œ×™× ×©Azure ××—×–×™×¨ ××˜×‘×œ××•×ª ×©×•× ×•×ª
    if (result.fields.Items && result.fields.Items.length > 0) {
        result.fields.Items = deduplicateItems(result.fields.Items);
    }

    const itemsData = extractRealItemsFromTable(tables, result.fields.Items);
    if (itemsData.length > 0) {
        result.fields.Items = itemsData;
    }

    const detectedNumbers = detectNumbersByContext(rawContent, result.fields);
    Object.assign(result.fields, detectedNumbers);

    // âœ¨ ×—×“×©! ×–×™×”×•×™ ×“×™× ××™ ×©×œ ××™×“×¢ ×™×™×—×•×“×™
    const uniqueData = extractUniqueData(rawContent, result.fields);
    if (uniqueData.length > 0) {
        result.fields.UnidentifiedNumbers = uniqueData;
    }

    const structure = buildStructure(result.fields);
    const data = buildData(result);

    return {
        structure: structure,
        data: data,
        metadata: {
            modelId: analyzeResult.modelId,
            totalFields: Object.keys(result.fields).length,
            uniqueDataFound: uniqueData.length,
            pageCount: analyzeResult.pages ? analyzeResult.pages.length : 0
        }
    };
}

function loadAnalyzeResult(input) {
    if (Array.isArray(input) && input[0] && input[0].analyzeResult) {
        return input[0].analyzeResult;
    }
    if (input.analyzeResult) {
        return input.analyzeResult;
    }
    if (input.content || input.tables) {
        return input;
    }
    throw new Error('Invalid input format');
}

function extractAzureFields(fields, target) {
    for (const fieldName in fields) {
        const fieldData = fields[fieldName];
        if (!fieldData) continue;
        
        const type = fieldData.type;
        
        if (type === 'string') {
            target[fieldName] = fieldData.valueString || fieldData.content;
        }
        else if (type === 'date') {
            target[fieldName] = fieldData.valueDate || fieldData.content;
        }
        else if (type === 'number') {
            target[fieldName] = fieldData.valueNumber;
        }
        else if (type === 'currency') {
            if (fieldData.valueCurrency) {
                target[fieldName + '_amount'] = fieldData.valueCurrency.amount;
                target[fieldName + '_currency'] = fieldData.valueCurrency.currencyCode;
            }
        }
        else if (type === 'address') {
            target[fieldName] = fieldData.content;
            if (fieldData.valueAddress) {
                for (const key in fieldData.valueAddress) {
                    const value = fieldData.valueAddress[key];
                    if (value) {
                        target[fieldName + '_' + key] = value;
                    }
                }
            }
        }
        else if (type === 'array') {
            if (fieldName === 'Items' && fieldData.valueArray) {
                target.Items = [];
                for (let i = 0; i < fieldData.valueArray.length; i++) {
                    const item = fieldData.valueArray[i];
                    if (item.valueObject) {
                        const itemData = {};
                        for (const key in item.valueObject) {
                            const val = item.valueObject[key];
                            if (val.type === 'currency' && val.valueCurrency) {
                                itemData[key + '_amount'] = val.valueCurrency.amount;
                                itemData[key + '_currency'] = val.valueCurrency.currencyCode;
                            }
                            else if (val.type === 'number') {
                                itemData[key] = val.valueNumber;
                            }
                            else {
                                itemData[key] = val.valueString || val.content;
                            }
                        }
                        target.Items.push(itemData);
                    }
                }
            }
            else if (fieldName === 'PaymentDetails' && fieldData.valueArray) {
                for (let i = 0; i < fieldData.valueArray.length; i++) {
                    const payment = fieldData.valueArray[i];
                    if (payment.valueObject) {
                        for (const key in payment.valueObject) {
                            const val = payment.valueObject[key];
                            target['PaymentDetails_' + key] = val.valueString || val.content;
                        }
                    }
                }
            }
        }
    }
}

function deduplicateItems(items) {
    if (!items || items.length === 0) {
        return items;
    }

    const uniqueItems = {};

    for (let i = 0; i < items.length; i++) {
        const item = items[i];
        const productCode = item.ProductCode || item.ProductCode_amount || '';

        if (!productCode) {
            // ×× ××™×Ÿ ProductCode, ×©××•×¨ ××ª ×”×¤×¨×™×˜ ×›××• ×©×”×•×
            uniqueItems['item_' + i] = item;
            continue;
        }

        // ×× ×”ProductCode ×›×‘×¨ ×§×™×™×, ×‘×—×¨ ××ª ×”×¤×¨×™×˜ ×”××œ× ×™×•×ª×¨
        if (uniqueItems[productCode]) {
            const existing = uniqueItems[productCode];
            const existingFields = Object.keys(existing).length;
            const currentFields = Object.keys(item).length;

            // ×©××•×¨ ××ª ×”×¤×¨×™×˜ ×¢× ×™×•×ª×¨ ×©×“×•×ª
            // ××• ××ª ×”×¤×¨×™×˜ ×©×™×© ×œ×• Amount (×¤×¨×™×˜ ×©×œ×)
            if (currentFields > existingFields ||
                (item.Amount_amount && !existing.Amount_amount)) {
                uniqueItems[productCode] = item;
            }
        } else {
            uniqueItems[productCode] = item;
        }
    }

    // ×”××¨ ×—×–×¨×” ×œ××¢×¨×š
    const result = [];
    for (const key in uniqueItems) {
        result.push(uniqueItems[key]);
    }

    return result;
}

function extractRealItemsFromTable(tables, azureItems) {
    if (azureItems && azureItems.length > 0) {
        return azureItems;
    }
    
    if (!tables || tables.length === 0) {
        return [];
    }
    
    let mainTable = {};
    let maxCells = 0;
    
    for (let i = 0; i < tables.length; i++) {
        const table = tables[i];
        if (table.cells && table.cells.length > maxCells) {
            mainTable = table;
            maxCells = table.cells.length;
        }
    }
    
    if (!mainTable.cells) {
        return [];
    }
    
    const headers = [];
    const dataCells = [];
    
    for (let i = 0; i < mainTable.cells.length; i++) {
        const cell = mainTable.cells[i];
        if (cell.kind === 'columnHeader') {
            headers.push(cell);
        } else {
            dataCells.push(cell);
        }
    }
    
    const columnMap = {};
    for (let i = 0; i < headers.length; i++) {
        const header = headers[i];
        columnMap[header.columnIndex] = {
            content: header.content,
            fieldName: guessFieldNameGeneric(header.content, header.columnIndex)
        };
    }
    
    const rowsData = {};
    for (let i = 0; i < dataCells.length; i++) {
        const cell = dataCells[i];
        const rowIdx = cell.rowIndex;
        
        if (!rowsData[rowIdx]) {
            rowsData[rowIdx] = {};
        }
        
        const colInfo = columnMap[cell.columnIndex];
        if (colInfo && cell.content && cell.content.trim()) {
            rowsData[rowIdx][colInfo.fieldName] = parseValue(cell.content);
        }
    }
    
    const items = [];
    const allRows = [];

    for (const rowIdx in rowsData) {
        const rowData = rowsData[rowIdx];
        allRows.push(rowData);
        if (isRealItemRow(rowData)) {
            items.push(rowData);
        }
    }

    // ×‘×“×™×§×ª ×‘×™×˜×—×•×Ÿ: ×× ×œ× × ××¦××• ×¤×¨×™×˜×™× ××‘×œ ×™×© ×©×•×¨×•×ª ×¢× ProductCode
    // ×–×” ×™×›×•×œ ×œ×”×™×•×ª ××§×¨×” ×œ×’×™×˜×™××™ ×©×œ ×¤×¨×™×˜×™× ×œ×œ× ××—×™×¨×™×
    if (items.length === 0 && allRows.length > 0) {
        for (let i = 0; i < allRows.length; i++) {
            const row = allRows[i];
            if (row.ProductCode && Object.keys(row).length >= 2) {
                items.push(row);
            }
        }
    }

    return items;
}

function guessFieldNameGeneric(content, colIndex) {
    if (!content || content.trim() === '') {
        return 'Col' + colIndex;
    }
    
    const text = content.toLowerCase();
    
    if (content === '=' || text.indexOf('total') >= 0 || text.indexOf('amount') >= 0 || 
        text.indexOf('×¡×›×•×') >= 0 || text.indexOf('×¡×”') >= 0) return 'Amount';
    if (content === '%' || text.indexOf('discount') >= 0 || text.indexOf('×”× ×—') >= 0) return 'Discount';
    if (text.indexOf('qty') >= 0 || text.indexOf('quantity') >= 0 || text.indexOf('×›××•×ª') >= 0) return 'Quantity';
    if (text.indexOf('price') >= 0 || text.indexOf('××—×™×¨') >= 0) return 'UnitPrice';
    if (text.indexOf('code') >= 0 || text.indexOf('sku') >= 0 || text.indexOf('item') >= 0 || 
        text.indexOf('××§') >= 0 || text.indexOf('×¤×¨×™×˜') >= 0) return 'ProductCode';
    if (text.indexOf('desc') >= 0 || text.indexOf('name') >= 0 || 
        text.indexOf('×ª××•×¨') >= 0 || text.indexOf('×©×') >= 0) return 'Description';
    if (text.indexOf('unit') >= 0 || text.indexOf('×™×—') >= 0) return 'Unit';
    
    return 'Col' + colIndex;
}

function isRealItemRow(rowData) {
    const keys = Object.keys(rowData);

    if (keys.length < 2) {
        return false;
    }

    const hasAmount = rowData.Amount !== undefined;
    const hasQuantity = rowData.Quantity !== undefined;
    const hasUnitPrice = rowData.UnitPrice !== undefined;

    // ×©×•×¨×” ×××™×ª×™×ª ×—×™×™×‘×ª ×œ×›×œ×•×œ ×œ×¤×—×•×ª ××—×“ ××”×©×“×•×ª ×”××¡×¤×¨×™×™×:
    // Amount, Quantity, ××• UnitPrice
    // ×©×•×¨×•×ª ×¢× ×¨×§ ProductCode + Description ×”×Ÿ ×©×•×¨×•×ª ×”××©×š
    if (!hasAmount && !hasQuantity && !hasUnitPrice) {
        return false;
    }

    // ×× ×™×© Amount ×‘×•×“×§ ×©×”×•× ×ª×§×™×Ÿ
    if (hasAmount) {
        const amount = rowData.Amount;
        if (typeof amount === 'number' && amount > 0) {
            return true;
        }
    }

    // ×× ×™×© Quantity ××• UnitPrice - ×–×” ×¤×¨×™×˜ ×ª×§×™×Ÿ
    if (hasQuantity || hasUnitPrice) {
        return true;
    }

    return false;
}

function parseValue(value) {
    if (typeof value !== 'string') return value;
    
    const cleaned = value.replace(/,/g, '').trim();
    const numPattern = new RegExp('^[0-9]+\\.?[0-9]*$');
    
    if (numPattern.test(cleaned)) {
        const num = parseFloat(cleaned);
        if (!isNaN(num)) {
            return num;
        }
    }
    
    return value;
}

function detectNumbersByContext(content, existingFields) {
    const detected = {};
    
    if (!content) return detected;
    
    detectVendorAdditionalId(content, existingFields, detected);
    detectPhoneNumbers(content, existingFields, detected);
    detectTimes(content, existingFields, detected);
    detectDates(content, existingFields, detected);
    detectBankDetails(content, existingFields, detected);
    detectEmails(content, existingFields, detected);
    
    return detected;
}

function findAllNumbers(content, minLen, maxLen) {
    const numbers = [];
    const pattern = new RegExp('\\b(\\d{' + minLen + ',' + maxLen + '})\\b', 'g');
    const matches = content.match(pattern) || [];
    for (let i = 0; i < matches.length; i++) {
        numbers.push(matches[i]);
    }
    return numbers;
}

function detectVendorAdditionalId(content, existing, detected) {
    const companyIdx = content.indexOf('Company');
    if (companyIdx === -1) return;

    const afterCompany = content.substring(companyIdx);
    const numbers = findAllNumbers(afterCompany, 9, 10);

    if (numbers.length >= 2) {
        const first = numbers[0];
        const second = numbers[1];

        if (second !== first &&
            second !== existing.VendorTaxId &&
            second !== existing.CustomerTaxId) {
            detected.VendorAdditionalId = second;
        }
    }
}

function detectPhoneNumbers(content, existing, detected) {
    const phonePattern = new RegExp('[0-9]{2,3}[-\\s][0-9]{7,8}', 'g');
    const matches = content.match(phonePattern) || [];
    
    const usedNumbers = [];
    if (existing.VendorTaxId) usedNumbers.push(existing.VendorTaxId);
    if (existing.CustomerTaxId) usedNumbers.push(existing.CustomerTaxId);
    
    const phones = [];
    for (let i = 0; i < matches.length; i++) {
        const phone = matches[i];
        
        if (phone.indexOf('\n') >= 0 || phone.indexOf('\r') >= 0) {
            continue;
        }
        
        const cleanPhone = phone.replace(/[-\s]/g, '');
        
        let isUsed = false;
        for (let j = 0; j < usedNumbers.length; j++) {
            if (usedNumbers[j] === cleanPhone) {
                isUsed = true;
                break;
            }
        }
        
        if (!isUsed) {
            const position = content.indexOf(phone);
            phones.push({
                phone: phone,
                position: position,
                isVendor: position < content.length / 3
            });
        }
    }
    
    const vendorPhones = [];
    const customerPhones = [];
    
    for (let i = 0; i < phones.length; i++) {
        if (phones[i].isVendor) {
            vendorPhones.push(phones[i]);
        } else {
            customerPhones.push(phones[i]);
        }
    }
    
    if (vendorPhones.length > 0 && !existing.VendorTel) {
        detected.VendorTel = vendorPhones[0].phone;
    }
    if (vendorPhones.length > 1 && !existing.VendorFax) {
        detected.VendorFax = vendorPhones[1].phone;
    }
    if (customerPhones.length > 0 && !existing.CustomerTel) {
        detected.CustomerTel = customerPhones[0].phone;
    }
    if (customerPhones.length > 1 && !existing.CustomerFax) {
        detected.CustomerFax = customerPhones[1].phone;
    }
}

function detectTimes(content, existing, detected) {
    const timePattern = new RegExp('[0-9]{1,2}:[0-9]{2}(:[0-9]{2})?', 'g');
    const matches = content.match(timePattern) || [];
    
    if (matches.length > 0 && !existing.InvoiceTime) {
        detected.InvoiceTime = matches[0];
    }
    if (matches.length > 1 && !existing.PrintTime) {
        detected.PrintTime = matches[matches.length - 1];
    }
}

function detectDates(content, existing, detected) {
    const dates = [];
    
    const pattern1 = new RegExp('[0-9]{1,2}[./][0-9]{1,2}[./][0-9]{4}', 'g');
    const matches1 = content.match(pattern1) || [];
    for (let i = 0; i < matches1.length; i++) {
        const parsed = parseDateString(matches1[i]);
        if (parsed) {
            dates.push({
                date: parsed,
                position: content.indexOf(matches1[i])
            });
        }
    }
    
    dates.sort(function(a, b) { return a.position - b.position; });
    
    if (dates.length > 0 && !existing.InvoiceDate) {
        detected.InvoiceDate = dates[0].date;
    }
    if (dates.length > 1 && !existing.DueDate) {
        detected.DueDate = dates[dates.length - 1].date;
    }
}

function parseDateString(dateStr) {
    const parts1 = dateStr.match(/([0-9]{1,2})[./]([0-9]{1,2})[./]([0-9]{4})/);
    if (parts1) {
        const day = parts1[1].length === 1 ? '0' + parts1[1] : parts1[1];
        const month = parts1[2].length === 1 ? '0' + parts1[2] : parts1[2];
        return parts1[3] + '-' + month + '-' + day;
    }
    
    return null;
}

function detectBankDetails(content, existing, detected) {
    if (!existing.PaymentDetails_IBAN) {
        const ibanIdx = content.indexOf('IBAN');
        if (ibanIdx >= 0) {
            const afterIban = content.substring(ibanIdx);
            const ibanPattern = new RegExp('IL[0-9]{21}');
            const match = afterIban.match(ibanPattern);
            if (match) {
                detected.PaymentDetails_IBAN = match[0];
                
                const accountNum = match[0].substring(match[0].length - 6);
                if (!existing.PaymentDetails_AccountNumber) {
                    detected.PaymentDetails_AccountNumber = accountNum;
                }
            }
        }
    }
    
    if (!existing.PaymentDetails_SWIFT) {
        const swiftIdx = content.indexOf('SWIFT');
        if (swiftIdx >= 0) {
            const afterSwift = content.substring(swiftIdx);
            const swiftPattern = new RegExp('[A-Z0-9]{8,11}');
            const match = afterSwift.match(swiftPattern);
            if (match) {
                detected.PaymentDetails_SWIFT = match[0];
            }
        }
    }
}

function detectEmails(content, existing, detected) {
    const emailPattern = new RegExp('[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}', 'g');
    const matches = content.match(emailPattern) || [];
    
    for (let i = 0; i < matches.length; i++) {
        const email = matches[i];
        const position = content.indexOf(email);
        const isVendor = position < content.length / 3;
        
        if (isVendor && !existing.VendorEmail && !detected.VendorEmail) {
            detected.VendorEmail = email;
        } else if (!isVendor && !existing.CustomerEmail && !detected.CustomerEmail) {
            detected.CustomerEmail = email;
        }
    }
}

// ================================================================
// ×—×™×œ×•×¥ ×’× ×¨×™ ×©×œ ××™×“×¢ ×™×™×—×•×“×™
// ================================================================

function extractUniqueData(content, existingFields) {
    const uniqueData = [];
    const seen = {};

    // 1. ×–×•×’×•×ª "×ª×•×•×™×ª: ×¢×¨×š"
    const pairs = extractLabelValuePairs(content, existingFields);
    for (let i = 0; i < pairs.length; i++) {
        if (!seen[pairs[i].value]) {
            uniqueData.push(pairs[i]);
            seen[pairs[i].value] = true;
        }
    }

    // 2. ××¡×¤×¨×™× ×¢× ×¤×•×¨××˜ ××™×•×—×“ (××§×¤×™×, ×§×•×•×™× × ×˜×•×™×™×) - ×œ×¤× ×™ pure numbers!
    const formattedNumbers = extractFormattedNumbers(content, existingFields);
    for (let i = 0; i < formattedNumbers.length; i++) {
        if (!seen[formattedNumbers[i].value]) {
            uniqueData.push(formattedNumbers[i]);
            seen[formattedNumbers[i].value] = true;

            // ×¡××Ÿ ×’× ××ª ×”×—×œ×§×™× ×›×“×™ ×œ×× ×•×¢ ×›×¤×™×œ×•×™×•×ª (741-69-103 -> ×’× 741, 69, 103)
            const parts = formattedNumbers[i].value.split('-');
            for (let p = 0; p < parts.length; p++) {
                seen[parts[p]] = true;
            }
        }
    }

    // 3. ×›×œ ×”××¡×¤×¨×™× (3-20 ×¡×¤×¨×•×ª)
    const pureNumbers = extractAllPureNumbers(content, existingFields, 3, 20);
    for (let i = 0; i < pureNumbers.length; i++) {
        if (!seen[pureNumbers[i].value]) {
            uniqueData.push(pureNumbers[i]);
            seen[pureNumbers[i].value] = true;
        }
    }

    // 4. ×›×œ ×”×§×•×“×™× ×”××œ×¤×-× ×•××¨×™×™× (×œ×¤×—×•×ª 5 ×ª×•×•×™×)
    const alphaCodes = extractAlphanumericCodes(content, existingFields, 5, 30);
    for (let i = 0; i < alphaCodes.length; i++) {
        if (!seen[alphaCodes[i].value]) {
            uniqueData.push(alphaCodes[i]);
            seen[alphaCodes[i].value] = true;
        }
    }

    return uniqueData;
}

function extractLabelValuePairs(content, existing) {
    const pairs = [];
    const lines = content.split('\n');
    const patterns = [
        /^([×-×ªA-Za-z\s\.]+):\s*([^\n]+)$/,
        /^([×-×ªA-Za-z\s\.]{2,20})\s{2,}([^\n]+)$/
    ];
    for (let i = 0; i < lines.length; i++) {
        const line = lines[i].trim();
        if (!line || line.length < 5) continue;
        for (let p = 0; p < patterns.length; p++) {
            const match = line.match(patterns[p]);
            if (match) {
                const label = match[1].trim();
                const value = match[2].trim();
                if (!isValueExists(value, existing) && !isCommonLabel(label)) {
                    pairs.push({label: label, value: value});
                }
                break;
            }
        }
    }
    return pairs;
}

function extractFormattedNumbers(content, existing) {
    const numbers = [];

    // ×–×™×”×•×™ ××¡×¤×¨×™× ×¢× ××§×¤×™× (×›××• ××¡×¤×¨ ×¨×™×©×•×™: 741-69-103)
    // ××—×¤×© ×œ×¤×—×•×ª 2 ×—×œ×§×™× ××¡×¤×¨×™×™× ×¢× ××§×£ ×‘×™× ×™×”×
    const hyphenPattern = /\b(\d{1,4}-\d{1,4}(?:-\d{1,4})*)\b/g;
    const matches = content.match(hyphenPattern) || [];

    for (let i = 0; i < matches.length; i++) {
        const num = matches[i];

        // ×“×œ×’ ×¢×œ ×ª××¨×™×›×™× (DD/MM/YY ××• DD-MM-YY)
        if (/^\d{1,2}[-\/]\d{1,2}[-\/]\d{2,4}$/.test(num)) {
            continue;
        }

        // ×“×œ×’ ×× ×›×‘×¨ ×§×™×™× ×‘×©×“×•×ª ××—×¨×™×
        if (!isValueExists(num, existing)) {
            numbers.push({label: '××¡×¤×¨', value: num});
        }
    }

    return numbers;
}

function extractAllPureNumbers(content, existing, minLen, maxLen) {
    const numbers = [];
    const pattern = new RegExp('\\b(\\d{' + minLen + ',' + maxLen + '})\\b', 'g');
    const matches = content.match(pattern) || [];
    for (let i = 0; i < matches.length; i++) {
        const num = matches[i];
        if (!isValueExists(num, existing)) {
            numbers.push({label: '××¡×¤×¨', value: num});
        }
    }
    return numbers;
}

function extractAlphanumericCodes(content, existing, minLen, maxLen) {
    const codes = [];
    const pattern = new RegExp('\\b([A-Za-z0-9]{' + minLen + ',' + maxLen + '})\\b', 'g');
    const matches = content.match(pattern) || [];
    for (let i = 0; i < matches.length; i++) {
        const code = matches[i];
        if (/[A-Za-z]/.test(code) && /\d/.test(code) && !isValueExists(code, existing)) {
            codes.push({label: '×§×•×“', value: code});
        }
    }
    return codes;
}

function normalizeValue(value) {
    // Remove special characters (hyphens, spaces, dots, parentheses, colons)
    return value.toString().replace(/[-\s.():]/g, '').toLowerCase();
}

function isValueExists(value, existing) {
    const valueStr = value.toString().toLowerCase();
    const normalizedValue = normalizeValue(value);

    // Skip very short values (less than 3 chars) as they create too many false positives
    if (normalizedValue.length < 3) {
        return false;
    }

    for (const key in existing) {
        const fieldValue = existing[key];

        if (typeof fieldValue === 'string') {
            const fieldStr = fieldValue.toLowerCase();
            const normalizedField = normalizeValue(fieldValue);

            // Exact match (before normalization)
            if (fieldStr === valueStr) {
                return true;
            }

            // Check if value is part of field (after normalization)
            if (normalizedField.includes(normalizedValue)) {
                // If it's a prefix or suffix, filter it out (e.g., "052" in "052-5457201")
                if (normalizedField.startsWith(normalizedValue) || normalizedField.endsWith(normalizedValue)) {
                    return true;
                }

                // If it's in the middle, only filter if it's a significant portion (50%+)
                // This prevents "256" from being filtered just because it's in "SI256SP005599"
                const lengthRatio = normalizedValue.length / normalizedField.length;
                if (lengthRatio >= 0.5) {
                    return true;
                }
            }
        } else if (typeof fieldValue === 'number') {
            if (fieldValue.toString() === valueStr) {
                return true;
            }
        } else if (Array.isArray(fieldValue)) {
            for (let i = 0; i < fieldValue.length; i++) {
                const item = fieldValue[i];
                if (typeof item === 'string') {
                    const itemStr = item.toLowerCase();
                    const normalizedItem = normalizeValue(item);

                    if (itemStr === valueStr) {
                        return true;
                    }

                    if (normalizedItem.includes(normalizedValue)) {
                        if (normalizedItem.startsWith(normalizedValue) || normalizedItem.endsWith(normalizedValue)) {
                            return true;
                        }
                        const lengthRatio = normalizedValue.length / normalizedItem.length;
                        if (lengthRatio >= 0.5) {
                            return true;
                        }
                    }
                }
                if (typeof item === 'object') {
                    if (isValueExists(value, item)) {
                        return true;
                    }
                }
            }
        } else if (typeof fieldValue === 'object' && fieldValue !== null) {
            if (isValueExists(value, fieldValue)) {
                return true;
            }
        }
    }
    return false;
}

function isCommonLabel(label) {
    // ×¨×©×™××ª ×›×•×ª×¨×•×ª × ×¤×•×¦×•×ª ×©×œ× ××¢× ×™×™× ×•×ª
    const common = [
        'total', 'sum', '×¡×š', '×¡×›×•×', 'page', '×¢××•×“',
        'date', '×ª××¨×™×š', 'amount', '×›××•×ª', 'price', '××—×™×¨'
    ];
    
    const labelLower = label.toLowerCase();
    for (let i = 0; i < common.length; i++) {
        if (labelLower.indexOf(common[i]) >= 0) {
            return true;
        }
    }
    
    return false;
}

function buildStructure(fields) {
    const structure = {
        docType: "string",
        fields: {}
    };
    
    for (const fieldName in fields) {
        const fieldValue = fields[fieldName];
        if (fieldName === 'Items') {
            structure.Items = buildItemsStructure(fieldValue);
        }
        else if (fieldName === 'UnidentifiedNumbers') {
            structure.fields.UnidentifiedNumbers = ["object"];
        }
        else if (Array.isArray(fieldValue)) {
            structure.fields[fieldName] = ["string"];
        }
        else {
            structure.fields[fieldName] = getFieldType(fieldName, fieldValue);
        }
    }
    
    return structure;
}

function buildItemsStructure(items) {
    if (!items || items.length === 0) {
        return [];
    }
    
    const itemStructure = {};
    const firstItem = items[0];
    
    for (const fieldName in firstItem) {
        itemStructure[fieldName] = getFieldType(fieldName, firstItem[fieldName]);
    }
    
    return [itemStructure];
}

function getFieldType(fieldName, fieldValue) {
    if (fieldName.indexOf('Date') >= 0) return "YYYY-MM-DD";
    if (fieldName.indexOf('Time') >= 0) return "HH:MM:SS";
    if (fieldName.indexOf('_amount') >= 0) return "number";
    if (fieldName.indexOf('_currency') >= 0) return "string";
    if (typeof fieldValue === 'number') return "number";
    return "string";
}

function buildData(result) {
    return {
        docType: result.docType,
        fields: result.fields
    };
}

// ×”×¨×¥ ××ª ×”×¤×•× ×§×¦×™×” ×•×”×—×–×¨ ×ª×•×¦××”
const finalResult = processAzureInvoice(azureJsonInput);

finalResult.status = 'success';

return finalResult;

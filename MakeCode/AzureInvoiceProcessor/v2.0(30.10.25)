// ================================================================
// Azure Invoice Processor v2.23 - EXPANDED STRUCTURE: vendor mapping
// ×¢×•×“×›×Ÿ: 13 × ×•×‘××‘×¨ 2025 (FIX #2)
// ================================================================
// ×©×™× ×•×™×™× ×‘-v2.23:
// ğŸ¯ EXPANDED STRUCTURE: ××‘× ×” ××•×¨×—×‘ ×œ×–×™×”×•×™ ×¡×¤×§ ×¢×ª×™×“×™
//
//    ××˜×¨×”: ×©×™×¤×•×¨ ××¢×¨×›×ª ×”××™×¤×•×™ ×œ×–×™×”×•×™ ×¡×¤×§×™× ×—×“×©×™×
//
//    ×©×™×¤×•×¨×™×:
//    1. âœ… ××™×œ×•×Ÿ ×ª×¨×’×•× ××•×¨×—×‘ ×¢×‘×¨×™×ª-×× ×’×œ×™×ª
//       - ×¤×•× ×§×¦×™×”: getHeaderTranslationMap()
//       - ××™×¤×•×™ ××œ×: ×©×•×¨×”â†’LineNumber, ×”×–×× ×ª×›×â†’CustomerOrder, ×•×›×•'
//       - 10 ×©×“×•×ª ×¡×˜× ×“×¨×˜×™×™× ×¢× ×ª×¨×’×•××™× ×“×•-×œ×©×•× ×™×™×
//
//    2. âœ… guessFieldNameGeneric() ××—×–×™×¨ ××•×‘×™×™×§×˜ ××•×¨×—×‘
//       - ×œ×¤× ×™: ××—×–×™×¨ ×¨×§ string (×©× ×”×©×“×”)
//       - ×¢×›×©×™×•: { fieldName, originalHeader, isUnknown }
//       - ×©××™×¨×ª ×”×›×•×ª×¨×ª ×”××§×•×¨×™×ª ××”××¡××š
//
//    3. âœ… extractRealItemsFromTable() - ××—×–×™×¨ items + columnMap
//       - ×œ×¤× ×™: ××—×–×™×¨ ×¨×§ ××¢×¨×š ×¤×¨×™×˜×™×
//       - ×¢×›×©×™×•: { items: [], columnMap: {} }
//       - columnMap ×©×•××¨ originalHeader ×œ×›×œ ×¢××•×“×”
//       - ğŸ”§ FIX: ×ª××™×“ ×× ×ª×— ×˜×‘×œ×” ×ª×—×™×œ×” (×œ× ××“×œ×’ ×¢×œ × ×™×ª×•×—!)
//
//    4. âœ… buildItemsStructure() - structure ××•×¨×—×‘
//       - ×œ×¤× ×™: ProductCode: "string"
//       - ×¢×›×©×™×•: ProductCode: { type: "string", originalHeader: "××§\"×˜" }
//       - ×××¤×©×¨ ×–×™×”×•×™ ×¡×¤×§ ×¢×ª×™×“×™ ×œ×¤×™ ×”×›×•×ª×¨×•×ª ×”××§×•×¨×™×•×ª
//       - ğŸ”§ FIX: buildAzureFieldToHeaderMap() ×œ××™×¤×•×™ ×©×“×•×ª Azure
//
//    5. âœ… ×©××™×¨×ª ×¢××•×“×•×ª ×œ× ××–×•×”×•×ª
//       - ×¢××•×“×•×ª ×©×œ× ××–×•×”×• â† UnknownColumn_N
//       - ×©×•××¨ originalHeader ×’× ×œ×¢××•×“×•×ª ×œ× ×™×“×•×¢×•×ª
//       - ××£ ××™×“×¢ ×œ× × ×–×¨×§!
//
//    6. âœ… isRealItemRow() - ×ª××™×›×” ×‘-TotalPrice
//       - ×ª××™×›×” ×‘×©××•×ª ×©×“×•×ª ×—×“×©×™× (TotalPrice) ×•×™×©× ×™× (Amount)
//       - ××–×”×” ×©×•×¨×•×ª ×ª×§×™× ×•×ª ×¢× TotalPrice ×‘××§×•× Amount
//
//    7. âœ… buildAzureFieldToHeaderMap() - ××™×¤×•×™ ×©×“×•×ª Azure
//       - ×××¤×” Amount_amount â†’ TotalPrice â†’ "×¡×”\"×› ××—×™×¨"
//       - ×××¤×” UnitPrice_amount â†’ UnitPrice â†’ "××—×™×¨ ×œ×™×—×™×“×”"
//       - ×ª×•×× ×‘×™×Ÿ ×©×“×•×ª Azure ×”××¢×•×‘×“×™× ×œ×›×•×ª×¨×•×ª ×”××§×•×¨×™×•×ª
//
// ×©×™× ×•×™×™× ×§×•×“××™× (v2.22):
// ğŸ§¹ CODE CLEANUP: ×¨×™×¤×§×˜×•×¨ ×•×™×™×¢×•×œ ×§×•×“
//
// ×©×™× ×•×™×™× ×§×•×“××™× (v2.21):
// ğŸ”´ FIX: lists with URLs and long mixed content
//
// ×©×™× ×•×™×™× ×§×•×“××™× (v2.20):
// ğŸ”´ FIX: mobile phones, OCR artifacts, lists, cleanup
//
// ×©×™× ×•×™×™× ×§×•×“××™× (v2.19):
// ğŸ”´ FIX: sentences, short hyphenated numbers, partial codes
//
// ×©×™× ×•×™×™× ×§×•×“××™× (v2.18):
// ğŸ”´ FIX: phones, dates, system names
//
// ×©×™× ×•×™×™× ×§×•×“××™× (v2.17):
// ğŸ”´ FIX: isList broken + noise values + phone parts
//
// ×©×™× ×•×™×™× ×§×•×“××™× (v2.16):
// ğŸ¯ GENERIC APPROACH + ×‘×™×˜×•×œ currentSection
// ================================================================
//
// âš ï¸ ×—×•×‘×”! ×œ×¤× ×™ ×›×œ ×ª×™×§×•×Ÿ - ×‘×“×•×§ ×‘×§×•×“×™× ×”×‘××™×:
// - Processing Invoice (v4.2-COMPLETE.js)
// - Production Invoice (v1.0-production.js)
//
// ğŸ“ ×§×‘×¦×™ ×‘×“×™×§×”:
// - MakeCode/AzureInvoiceProcessor/EXEMPTS/input.txt + output.txt
// - MakeCode/Processing Invoice/QA/
// - MakeCode/Production Invoice/QA/
//
// ğŸ“– ×ª×™×¢×•×“ ××¤×•×¨×˜ ×•×”×™×¡×˜×•×¨×™×”: ×¨××” README.md
// ================================================================

// ============================================================================
// TextStandardization Functions (embedded - Make.com compatible)
// ============================================================================

function removeInvisibleCharacters(text) {
    return text
        .replace(/[\u200B-\u200D\uFEFF]/g, '')
        .replace(/\u00A0/g, ' ')
        .replace(/\u00AD/g, '')
        .replace(/[\u200E\u200F]/g, '')
        .replace(/[\u0000-\u0008\u000B-\u000C\u000E-\u001F\u007F-\u009F]/g, '');
}

function normalizeLineBreaks(text) {
    return text
        .replace(/\r\n/g, '\n')
        .replace(/\r/g, '\n')
        .replace(/\n{3,}/g, '\n\n');
}

function normalizeWhitespace(text) {
    return text
        .replace(/\t/g, ' ')
        .replace(/  +/g, ' ')
        .replace(/^ +/gm, '')
        .replace(/ +$/gm, '')
        .replace(/ +([,.:;!?])/g, '$1')
        .replace(/\(\s+/g, '(')
        .replace(/\s+\)/g, ')');
}

function normalizeHyphens(text) {
    return text
        .replace(/\u2013/g, '-')
        .replace(/\u2014/g, '-')
        .replace(/\u2212/g, '-')
        .replace(/\u2012/g, '-')
        .replace(/\u2015/g, '-');
}

function normalizeHebrew(text) {
    return text
        .replace(/\u05F4/g, '"')
        .replace(/\u05F3/g, "'")
        .replace(/[\u05BE\u05C0]/g, '-');
}

function standardizeText(text, options) {
    if (!text || typeof text !== 'string') return "";

    const opts = {
        removeInvisibleChars: true,
        normalizeWhitespace: true,
        normalizeLineBreaks: true,
        normalizeHyphens: true,
        normalizeHebrew: true,
        ...options
    };

    let cleaned = text;

    if (opts.removeInvisibleChars) {
        cleaned = removeInvisibleCharacters(cleaned);
    }
    if (opts.normalizeLineBreaks) {
        cleaned = normalizeLineBreaks(cleaned);
    }
    if (opts.normalizeWhitespace) {
        cleaned = normalizeWhitespace(cleaned);
    }
    if (opts.normalizeHyphens) {
        cleaned = normalizeHyphens(cleaned);
    }
    if (opts.normalizeHebrew) {
        cleaned = normalizeHebrew(cleaned);
    }

    return cleaned.trim();
}

// ============================================================================
// ×¤×•× ×§×¦×™×•×ª × ×¨××•×œ ×¢×¨×›×™× (××§×•×“ DataNormalizer)
// ============================================================================

/**
 * ×‘×“×•×§ ×× ×¢×¨×š ×”×•× ×¨×©×™××” - ×–×™×”×•×™ ×’× ×¨×™ ×œ×¤×™ ×ª×‘× ×™×ª, ×œ× ××™×œ×•×ª ××¤×ª×—!
 * ×ª×‘× ×™×•×ª ×©×œ ×¨×©×™××•×ª:
 * 1. "X: Y, Z: W" - ×–×•×’×•×ª ××¤×ª×—-×¢×¨×š (×¤×¡×™×§ + × ×§×•×“×”-×©×ª×™×™× ×‘××™×œ×™×)
 * 2. "X, Y, Z" - ×¨×©×™××” ×©×œ ×¢×¨×›×™× (2+ ×¤×¡×™×§×™×)
 * 3. "X; Y" - × ×§×•×“×”-×¤×¡×™×§
 * 4. "X | Y" - pipe (×§×• ×× ×›×™)
 */
function isList(value) {
    if (typeof value !== 'string') return false;

    // ×¨×©×™××” ×× ×™×© × ×§×•×“×”-×¤×¡×™×§ ××• pipe
    if (value.includes(';') || value.includes('|')) return true;

    // âš ï¸ FIX v2.21: ×¨×©×™××” ×× ×™×© URL/website
    // "04-6333334 ×¤×§×¡': 04-6344123 www.toyota-sos.co.il" â† ×™×© www = ×¨×©×™××”!
    if (value.includes('www.') || value.includes('http://') || value.includes('https://')) {
        return true;
    }

    const commaCount = (value.match(/,/g) || []).length;
    const colonCount = (value.match(/:/g) || []).length;

    // ×¨×©×™××” ×× ×™×© 2+ ×¤×¡×™×§×™× (×œ×¤×—×•×ª 3 ×¤×¨×™×˜×™×)
    if (commaCount >= 2) return true;

    // ×× ×™×© 1 ×¤×¡×™×§ - ×‘×“×•×§ ×× ×™×© ××‘× ×” ×©×œ ×–×•×’×•×ª ×¢× × ×§×•×“×”-×©×ª×™×™×
    if (commaCount >= 1 && colonCount >= 1) {
        const hasWords = /[×-×ªa-zA-Z]{2,}/.test(value);
        if (hasWords) {
            return true; // "04-6445585, ×¤×§×¡: 1534-6438399" â† ×¨×©×™××”!
        }
    }

    // âš ï¸ FIX v2.20: ×¨×©×™××” ×× ×™×© 2+ × ×§×•×“×•×ª×™×™× + ××™×œ×™× (×’× ×œ×œ× ×¤×¡×™×§!)
    // "×˜×œ': 04-6333334 ×¤×§×¡': 04-6344123" â† ×™×© 2 × ×§×•×“×•×ª×™×™× + ××™×œ×™× = ×¨×©×™××”!
    if (colonCount >= 2) {
        const hasWords = /[×-×ªa-zA-Z]{2,}/.test(value);
        if (hasWords) {
            return true;
        }
    }

    // âš ï¸ FIX v2.21: ×¨×©×™××” ×× ××¨×•×š ××“×™ ×¢× ××¡×¤×¨×™× ××¨×•×‘×™×
    // "04-6333334 ×¤×§×¡ 04-6344123" â† ××¨×•×š (>40) + 2 ××¡×¤×¨×™× = ×¨×©×™××”!
    if (value.length > 40) {
        const numberCount = (value.match(/\d{2,}/g) || []).length;
        if (numberCount >= 2) {
            return true;
        }
    }

    return false;
}

/**
 * × ×§×” ×›×•×ª×¨×ª/label ××ª×•×•×™× ××™×•×ª×¨×™×
 */
function cleanHeader(value) {
    if (typeof value !== 'string') return value;

    let cleaned = value;

    // ×”×¡×¨ ×ª×•×•×™× ××™×•×ª×¨×™× ×‘×”×ª×—×œ×”/×¡×•×£
    cleaned = cleaned.trim();

    // ×”×¡×¨ × ×§×•×“×•×ª ×‘×¡×•×£ (×× ×™×©)
    cleaned = cleaned.replace(/\.+$/, '');

    // ×”×¡×¨ × ×§×•×“×•×ª×™×™× ×‘×¡×•×£
    cleaned = cleaned.replace(/:+$/, '');

    // ×”×¡×¨ ×¨×•×•×—×™× ××¨×•×‘×™×
    cleaned = cleaned.replace(/\s{2,}/g, ' ');

    // ×”×¡×¨ ×¡×•×’×¨×™×™× ×¨×™×§×™×
    cleaned = cleaned.replace(/\(\s*\)/g, '');

    return cleaned.trim();
}

function cleanNumber(value) {
    if (typeof value !== 'string') return value;

    // âš ï¸ FIX v2.18: ××œ ×ª× ×¨××œ ×ª××¨×™×›×™× ×‘×¤×•×¨××˜ MM.YY ××• MM/YY
    // "06.25" ××• "06/25" ×–×” ×—×•×“×©/×©× ×”, ×œ× 6.25!
    if (/^\d{1,2}[.\/]\d{2}$/.test(value.trim())) {
        return value.trim(); // ×”×©××¨ ×›××• ×©×”×•× - ×–×” ×ª××¨×™×š!
    }

    const cleaned = value.replace(/[,\s]/g, '');

    // ×× ×–×” ×¨×¦×£ ×¡×¤×¨×•×ª ××¨×•×š ×××•×“ (>=16), ×œ× ×œ×”××™×¨ ×œ××¡×¤×¨ ×›×“×™ ×œ× ×œ××‘×“ ×“×™×•×§
    if (/^\d{16,}$/.test(cleaned)) {
        return value.trim(); // ×”×©××¨ ××—×¨×•×–×ª ××§×•×¨×™×ª
    }

    if (/^-?\d+\.?\d*$/.test(cleaned)) {
        const num = parseFloat(cleaned);
        return isNaN(num) ? value : num;
    }
    return value;
}

function normalizeDate(value) {
    if (typeof value !== 'string') return value;

    // ×¤×•×¨××˜ ISO: YYYY-MM-DD
    const isoMatch = value.match(/^(\d{4})-(\d{2})-(\d{2})$/);
    if (isoMatch) {
        const year = isoMatch[1];
        const month = isoMatch[2];
        const day = isoMatch[3];
        return `${day}/${month}/${year}`;
    }

    // ×¤×•×¨××˜ DD/MM/YY ××• DD/MM/YYYY
    const dateMatch1 = value.match(/^(\d{1,2})\/(\d{1,2})\/(\d{2,4})$/);
    if (dateMatch1) {
        const day = dateMatch1[1].padStart(2, '0');
        const month = dateMatch1[2].padStart(2, '0');
        let year = dateMatch1[3];

        if (year.length === 2) {
            year = parseInt(year) > 50 ? '19' + year : '20' + year;
        }

        return `${day}/${month}/${year}`;
    }

    return value;
}

function detectCurrencyInValue(value) {
    if (typeof value !== 'string') return null;

    // ××˜×‘×¢ ×‘×ª×—×™×œ×”: "USD 24.99"
    const prefixMatch = value.match(/^(ILS|USD|EUR|GBP|â‚ª|\$|â‚¬|Â£|×©"×—)\s+/);
    if (prefixMatch) return prefixMatch[1];

    // ××˜×‘×¢ ×‘×¡×•×£: "24.99 USD"
    const currencies = ['ILS', 'USD', 'EUR', 'GBP', 'â‚ª', '$', 'â‚¬', 'Â£', '×©"×—'];
    for (const curr of currencies) {
        if (value.includes(curr)) {
            return curr;
        }
    }
    return null;
}

function removeCurrency(value, currency) {
    if (typeof value !== 'string' || !currency) return value;
    return value.replace(currency, '').trim();
}

function isPercentageField(fieldName) {
    if (typeof fieldName !== 'string') return false;
    const lower = fieldName.toLowerCase();
    return lower.includes('××—×•×–') || lower.includes('percentage') ||
           lower.includes('percent') || lower.includes('×©×™×¢×•×¨') ||
           fieldName.includes('%');
}

function cleanPercentage(value) {
    if (typeof value !== 'string') return value;
    if (!value.endsWith('%')) return value;

    const cleaned = value.replace('%', '').trim();
    const num = parseFloat(cleaned);
    return isNaN(num) ? value : num;
}

const contentLong = input.contentLong || input.contentlong || '';
const pagesInput = input.pages || [];
const tablesInput = input.tables || [];
const documentsInput = input.documents || [];
const modelId = input.modelId || '';

const azureJsonInput = {
    content: contentLong,
    pages: pagesInput,
    tables: tablesInput,
    documents: documentsInput,
    modelId: modelId
};

function processAzureInvoice(azureInput) {
    const analyzeResult = loadAnalyzeResult(azureInput);

    // âœ¨ Apply TextStandardization as foundation layer
    const rawContentFromAzure = analyzeResult.content || '';
    const rawContent = standardizeText(rawContentFromAzure);

    const tables = analyzeResult.tables || [];
    const documents = analyzeResult.documents || [];

    const result = {
        docType: 'invoice',
        fields: {}
    };

    if (documents.length > 0 && documents[0].fields) {
        extractAzureFields(documents[0].fields, result.fields);
    }

    // ××—×“ ×¤×¨×™×˜×™× ×›×¤×•×œ×™× ×©Azure ××—×–×™×¨ ××˜×‘×œ××•×ª ×©×•× ×•×ª
    if (result.fields.Items && result.fields.Items.length > 0) {
        result.fields.Items = deduplicateItems(result.fields.Items);
    }

    // ×—×™×œ×•×¥ ×¤×¨×™×˜×™× ××˜×‘×œ××•×ª + ×©××™×¨×ª ××¤×ª ×¢××•×“×•×ª ××•×¨×—×‘×ª
    const itemsExtraction = extractRealItemsFromTable(tables, result.fields.Items);
    let columnMap = {};

    if (itemsExtraction.items && itemsExtraction.items.length > 0) {
        result.fields.Items = itemsExtraction.items;
        columnMap = itemsExtraction.columnMap;
    } else if (itemsExtraction.length > 0) {
        // ×ª××™×›×” ×œ××—×•×¨ - ×× azureItems ×§×™×™××™× (××¢×¨×š ×™×©×Ÿ)
        result.fields.Items = itemsExtraction;
    } else if (itemsExtraction.columnMap && Object.keys(itemsExtraction.columnMap).length > 0) {
        // ×™×© columnMap ××‘×œ ××™×Ÿ items ××”×˜×‘×œ×” - ×”×©×ª××© ×‘-azureItems
        columnMap = itemsExtraction.columnMap;
    }

    const detectedNumbers = detectNumbersByContext(rawContent, result.fields);
    Object.assign(result.fields, detectedNumbers);

    // âœ¨ ×—×“×©! ×–×™×”×•×™ ×“×™× ××™ ×©×œ ××™×“×¢ ×™×™×—×•×“×™
    const uniqueData = extractUniqueData(rawContent, result.fields);
    if (uniqueData.length > 0) {
        result.fields.UnidentifiedNumbers = uniqueData;
    }

    const structure = buildStructure(result.fields, columnMap);
    const data = buildData(result);

    return {
        structure: structure,
        data: data,
        metadata: {
            modelId: analyzeResult.modelId,
            totalFields: Object.keys(result.fields).length,
            uniqueDataFound: uniqueData.length,
            pageCount: analyzeResult.pages ? analyzeResult.pages.length : 0
        }
    };
}

function loadAnalyzeResult(input) {
    if (Array.isArray(input) && input[0] && input[0].analyzeResult) {
        return input[0].analyzeResult;
    }
    if (input.analyzeResult) {
        return input.analyzeResult;
    }
    if (input.content || input.tables) {
        return input;
    }
    throw new Error('Invalid input format');
}

function extractAzureFields(fields, target) {
    for (const fieldName in fields) {
        const fieldData = fields[fieldName];
        if (!fieldData) continue;
        
        const type = fieldData.type;
        
        if (type === 'string') {
            target[fieldName] = fieldData.valueString || fieldData.content;
        }
        else if (type === 'date') {
            target[fieldName] = fieldData.valueDate || fieldData.content;
        }
        else if (type === 'number') {
            target[fieldName] = fieldData.valueNumber;
        }
        else if (type === 'currency') {
            if (fieldData.valueCurrency) {
                target[fieldName + '_amount'] = fieldData.valueCurrency.amount;
                target[fieldName + '_currency'] = fieldData.valueCurrency.currencyCode;
            }
        }
        else if (type === 'address') {
            target[fieldName] = fieldData.content;
            if (fieldData.valueAddress) {
                for (const key in fieldData.valueAddress) {
                    const value = fieldData.valueAddress[key];
                    if (value) {
                        target[fieldName + '_' + key] = value;
                    }
                }
            }
        }
        else if (type === 'array') {
            if (fieldName === 'Items' && fieldData.valueArray) {
                target.Items = [];
                for (let i = 0; i < fieldData.valueArray.length; i++) {
                    const item = fieldData.valueArray[i];
                    if (item.valueObject) {
                        const itemData = {};
                        for (const key in item.valueObject) {
                            const val = item.valueObject[key];
                            if (val.type === 'currency' && val.valueCurrency) {
                                itemData[key + '_amount'] = val.valueCurrency.amount;
                                itemData[key + '_currency'] = val.valueCurrency.currencyCode;
                            }
                            else if (val.type === 'number') {
                                itemData[key] = val.valueNumber;
                            }
                            else {
                                itemData[key] = val.valueString || val.content;
                            }
                        }
                        target.Items.push(itemData);
                    }
                }
            }
            else if (fieldName === 'PaymentDetails' && fieldData.valueArray) {
                for (let i = 0; i < fieldData.valueArray.length; i++) {
                    const payment = fieldData.valueArray[i];
                    if (payment.valueObject) {
                        for (const key in payment.valueObject) {
                            const val = payment.valueObject[key];
                            target['PaymentDetails_' + key] = val.valueString || val.content;
                        }
                    }
                }
            }
        }
    }
}

function deduplicateItems(items) {
    if (!items || items.length === 0) {
        return items;
    }

    // âš ï¸ FIX v2.14: ××•×ª×• ProductCode ×™×›×•×œ ×œ×”×•×¤×™×¢ ×¤×¢××™×™× - ×–×” ×œ×’×™×˜×™××™!
    // ×“×“×•×¤×œ×™×§×¦×™×” ×¨×§ ×× **×›×œ ×”×©×“×•×ª ×”×—×©×•×‘×™× ×–×”×™×** (ProductCode + Amount + Quantity)

    const result = [];
    const seen = [];

    for (let i = 0; i < items.length; i++) {
        const item = items[i];

        // ×‘×“×•×§ ×× ×”×¤×¨×™×˜ ×”×–×” ×›×‘×¨ ×§×™×™× (×–×”×” ×œ×—×œ×•×˜×™×Ÿ)
        let isDuplicate = false;
        for (let j = 0; j < seen.length; j++) {
            const existing = seen[j];

            // ×¤×¨×™×˜ × ×—×©×‘ ×›×¤×™×œ×•×ª ×¨×§ ××:
            // 1. ProductCode ×–×”×” (××• ×©× ×™×”× ×—×¡×¨×™×)
            // 2. Amount ×–×”×” (××• ×©× ×™×”× ×—×¡×¨×™×)
            // 3. Quantity ×–×”×” (××• ×©× ×™×”× ×—×¡×¨×™×)

            const sameProductCode = (item.ProductCode || '') === (existing.ProductCode || '');
            const sameAmount = (item.Amount_amount || 0) === (existing.Amount_amount || 0);
            const sameQuantity = (item.Quantity || 0) === (existing.Quantity || 0);

            if (sameProductCode && sameAmount && sameQuantity) {
                // ×–×”×” ×œ×—×œ×•×˜×™×Ÿ - ×‘×—×¨ ××ª ×”××œ× ×™×•×ª×¨
                const existingFields = Object.keys(existing).length;
                const currentFields = Object.keys(item).length;

                if (currentFields > existingFields) {
                    // ×”×¤×¨×™×˜ ×”× ×•×›×—×™ ××œ× ×™×•×ª×¨ - ×”×—×œ×£
                    seen[j] = item;
                }
                // ××—×¨×ª - ×”×©××¨ ××ª ×”×§×™×™×
                isDuplicate = true;
                break;
            }
        }

        if (!isDuplicate) {
            seen.push(item);
            result.push(item);
        }
    }

    return result;
}

function extractRealItemsFromTable(tables, azureItems) {
    // âš ï¸ ×—×©×•×‘! ×ª××™×“ × ×ª×— ××ª ×”×˜×‘×œ×” ×ª×—×™×œ×” ×›×“×™ ×œ×‘× ×•×ª columnMap
    if (!tables || tables.length === 0) {
        // ××™×Ÿ ×˜×‘×œ×” - ×× ×™×© azureItems, ×”×—×–×¨ ××•×ª× ×¢× columnMap ×¨×™×§
        if (azureItems && azureItems.length > 0) {
            return {
                items: azureItems,
                columnMap: {}
            };
        }
        return {
            items: [],
            columnMap: {}
        };
    }

    let mainTable = {};
    let maxCells = 0;

    for (let i = 0; i < tables.length; i++) {
        const table = tables[i];
        if (table.cells && table.cells.length > maxCells) {
            mainTable = table;
            maxCells = table.cells.length;
        }
    }

    if (!mainTable.cells) {
        // ××™×Ÿ ×ª××™× ×‘×˜×‘×œ×” - ×× ×™×© azureItems, ×”×—×–×¨ ××•×ª× ×¢× columnMap ×¨×™×§
        if (azureItems && azureItems.length > 0) {
            return {
                items: azureItems,
                columnMap: {}
            };
        }
        return {
            items: [],
            columnMap: {}
        };
    }

    const headers = [];
    const dataCells = [];

    for (let i = 0; i < mainTable.cells.length; i++) {
        const cell = mainTable.cells[i];
        if (cell.kind === 'columnHeader') {
            headers.push(cell);
        } else {
            dataCells.push(cell);
        }
    }

    // ×‘× ×™×™×ª ××¤×ª ×¢××•×“×•×ª ××•×¨×—×‘×ª ×¢× originalHeader - ×ª××™×“!
    const columnMap = {};
    for (let i = 0; i < headers.length; i++) {
        const header = headers[i];
        const fieldInfo = guessFieldNameGeneric(header.content, header.columnIndex);
        columnMap[header.columnIndex] = {
            content: header.content,
            fieldName: fieldInfo.fieldName,
            originalHeader: fieldInfo.originalHeader,
            isUnknown: fieldInfo.isUnknown
        };
    }

    const rowsData = {};
    for (let i = 0; i < dataCells.length; i++) {
        const cell = dataCells[i];
        const rowIdx = cell.rowIndex;

        if (!rowsData[rowIdx]) {
            rowsData[rowIdx] = {};
        }

        const colInfo = columnMap[cell.columnIndex];
        if (colInfo && cell.content && cell.content.trim()) {
            rowsData[rowIdx][colInfo.fieldName] = parseValue(cell.content);
        }
    }

    const items = [];
    const allRows = [];

    for (const rowIdx in rowsData) {
        const rowData = rowsData[rowIdx];
        allRows.push(rowData);
        if (isRealItemRow(rowData)) {
            items.push(rowData);
        }
    }

    // ×‘×“×™×§×ª ×‘×™×˜×—×•×Ÿ: ×× ×œ× × ××¦××• ×¤×¨×™×˜×™× ××‘×œ ×™×© ×©×•×¨×•×ª ×¢× ProductCode
    // ×–×” ×™×›×•×œ ×œ×”×™×•×ª ××§×¨×” ×œ×’×™×˜×™××™ ×©×œ ×¤×¨×™×˜×™× ×œ×œ× ××—×™×¨×™×
    if (items.length === 0 && allRows.length > 0) {
        for (let i = 0; i < allRows.length; i++) {
            const row = allRows[i];
            if (row.ProductCode && Object.keys(row).length >= 2) {
                items.push(row);
            }
        }
    }

    // âœ… ×× ××™×Ÿ ×¤×¨×™×˜×™× ××”×˜×‘×œ×” ××‘×œ ×™×© azureItems - ×”×©×ª××© ×‘×”×
    // ××‘×œ ×©××•×¨ ××ª columnMap ×©× ×‘× ×” ××”×˜×‘×œ×”!
    if (items.length === 0 && azureItems && azureItems.length > 0) {
        return {
            items: azureItems,
            columnMap: columnMap
        };
    }

    return {
        items: items,
        columnMap: columnMap
    };
}

// ============================================================================
// ××™×œ×•×Ÿ ×ª×¨×’×•× ××•×¨×—×‘ - ×¢×‘×¨×™×ª ×œ×× ×’×œ×™×ª
// ============================================================================

/**
 * ××™×œ×•×Ÿ ×ª×¨×’×•× ××›×•×ª×¨×•×ª ×¢×‘×¨×™×•×ª/×× ×’×œ×™×•×ª ×œ×©××•×ª ×©×“×•×ª ×¡×˜× ×“×¨×˜×™×™×
 * ×›×œ ×¢×¨×š ××›×™×œ:
 * - field: ×©× ×”×©×“×” ×‘×× ×’×œ×™×ª
 * - hebrewHeaders: ××¢×¨×š ×©×œ ×›×•×ª×¨×•×ª ×‘×¢×‘×¨×™×ª
 * - englishHeaders: ××¢×¨×š ×©×œ ×›×•×ª×¨×•×ª ×‘×× ×’×œ×™×ª
 */
function getHeaderTranslationMap() {
    return [
        {
            field: 'LineNumber',
            hebrewHeaders: ['×©×•×¨×”', '××¡ ×©×•×¨×”', "××¡' ×©×•×¨×”", '××¡×¤×¨ ×©×•×¨×”', '×©', '#'],
            englishHeaders: ['line', 'line number', 'line no', 'row', 'row number', '#']
        },
        {
            field: 'CustomerOrder',
            hebrewHeaders: ['×”×–×× ×ª×›×', '×”×–×× ×ª ×œ×§×•×—', "××¡' ×”×–×× ×”", '××¡×¤×¨ ×”×–×× ×”', '×”×–×× ×”'],
            englishHeaders: ['customer order', 'your order', 'order number', 'order no', 'po number', 'po']
        },
        {
            field: 'ProductCode',
            hebrewHeaders: ['××§"×˜', '××§×˜', '×§×•×“ ×¤×¨×™×˜', '×§×•×“ ××•×¦×¨', '××§×´×˜'],
            englishHeaders: ['sku', 'item code', 'product code', 'code', 'item', 'part number', 'part no']
        },
        // ===== SPECIFIC COMPOUND TERMS (must come BEFORE generic terms!) =====
        {
            field: 'ChargeDescription',
            hebrewHeaders: ['×ª××•×¨ ×—×™×•×‘', '×ª×™××•×¨ ×—×™×•×‘'],
            englishHeaders: ['charge description']
        },
        {
            field: 'PricePerSqm',
            hebrewHeaders: ['××—×™×¨ ×œ×"×¨', '××—×™×¨ ×œ××´×¨', '××—×™×¨ ×œ××˜×¨', '××—×™×¨ ×œ×\'\'×¨'],
            englishHeaders: ['price per sqm', 'price per m2', 'price per square meter']
        },
        {
            field: 'BillableArea',
            hebrewHeaders: ['×©×˜×— ×œ×—×™×•×‘', '×©×˜×— ×œ×—×™×•×‘ ×‘×"×¨', '×©×˜×— ×œ×—×™×•×‘ ×‘××´×¨', '×©×˜×— ×‘×"×¨'],
            englishHeaders: ['billable area', 'area in sqm', 'chargeable area']
        },
        {
            field: 'AmountToCharge',
            hebrewHeaders: ['×¡×›×•× ×œ×—×™×•×‘', '×¡×”"×› ×œ×—×™×•×‘'],
            englishHeaders: ['amount to charge', 'total to charge']
        },
        {
            field: 'AmountBeforeLinkage',
            hebrewHeaders: ['×¡×›×•× ×œ×¤× ×™ ×”×¦××“×”', '×¡×›×•× ×œ×¤× ×™ ×”×¦××“×”', '×¡×›×•× ×œ×¤× ×™'],
            englishHeaders: ['amount before linkage', 'amount before indexation']
        },
        {
            field: 'LinkageCurrency',
            hebrewHeaders: ['××˜×‘×¢ ×”×¦××“×”', '××˜×‘×¢'],
            englishHeaders: ['linkage currency', 'currency']
        },
        {
            field: 'BaseRate',
            hebrewHeaders: ['×©×¢×¨ ×‘×¡×™×¡', '×©×¢×¨ ×™×¡×•×“'],
            englishHeaders: ['base rate', 'basic rate']
        },
        {
            field: 'CurrentRate',
            hebrewHeaders: ['×©×¢×¨ × ×•×›×—×™', '×©×¢×¨ ×¢×“×›× ×™'],
            englishHeaders: ['current rate', 'present rate']
        },
        {
            field: 'FromDate',
            hebrewHeaders: ['××ª××¨×™×š', '×-×ª××¨×™×š', '×ª××¨×™×š ×”×ª×—×œ×”'],
            englishHeaders: ['from date', 'start date']
        },
        {
            field: 'ToDate',
            hebrewHeaders: ['×¢×“ ×ª××¨×™×š', '×¢×“-×ª××¨×™×š', '×ª××¨×™×š ×¡×™×•×'],
            englishHeaders: ['to date', 'end date', 'until date']
        },
        {
            field: 'PaymentDetails',
            hebrewHeaders: ['×“.×ª×©×œ×•×', '×“ ×ª×©×œ×•×', '×¤×¨×˜×™ ×ª×©×œ×•×'],
            englishHeaders: ['payment details', 'payment info']
        },
        // ===== GENERIC TERMS (after specific terms) =====
        {
            field: 'Description',
            hebrewHeaders: ['×ª××•×¨', '×ª××•×¨ ××•×¦×¨', '×ª×™××•×¨', '×ª×™××•×¨ ××•×¦×¨', '×©× ××•×¦×¨', '×¤×¨×™×˜'],
            englishHeaders: ['description', 'item description', 'product description', 'name', 'product name', 'item name']
        },
        {
            field: 'Quantity',
            hebrewHeaders: ['×›××•×ª', '×›×', '×›××•×ª ××•×–×× ×ª'],
            englishHeaders: ['quantity', 'qty', 'amount', 'ordered qty']
        },
        {
            field: 'Unit',
            hebrewHeaders: ['×™×—×™×“×”', '×™×—', '×™×— ××™×“×”', '×™×—×™×“×ª ××™×“×”'],
            englishHeaders: ['unit', 'uom', 'unit of measure', 'measure']
        },
        {
            field: 'UnitPrice',
            hebrewHeaders: ['××—×™×¨ ×œ×™×—×™×“×”', '××—×™×¨ ×™×—×™×“×”', '××—×™×¨ ×œ×™×—', "××—×™×¨ ×œ×™×—'", '××—×™×¨'],
            englishHeaders: ['unit price', 'price per unit', 'price']
        },
        {
            field: 'TotalPrice',
            hebrewHeaders: ['×¡×”"×›', '×¡×”×´×›', '×¡×”"×› ××—×™×¨', '×¡×š ×”×›×œ', '×¡×›×•× ×›×•×œ×œ', '×¡×›×•×'],
            englishHeaders: ['total', 'total price', 'sum', 'total amount', 'line total', 'amount']
        },
        {
            field: 'Discount',
            hebrewHeaders: ['×”× ×—×”', '××—×•×– ×”× ×—×”', '% ×”× ×—×”'],
            englishHeaders: ['discount', 'discount %', 'disc', 'discount percent']
        },
        {
            field: 'Tax',
            hebrewHeaders: ['××¢"×', '××¢×', '××¡', '××¢×´×'],
            englishHeaders: ['tax', 'vat', 'sales tax']
        }
    ];
}

function guessFieldNameGeneric(content, colIndex) {
    if (!content || content.trim() === '') {
        return {
            fieldName: 'UnknownColumn_' + colIndex,
            originalHeader: '',
            isUnknown: true
        };
    }

    const originalHeader = content.trim();
    const text = content.toLowerCase().trim();

    // × ×¡×” ×œ××¦×•× ×”×ª×××” ×‘××™×œ×•×Ÿ ×”×ª×¨×’×•×
    const translationMap = getHeaderTranslationMap();

    // PASS 1: Try EXACT matches first (highest priority)
    for (let i = 0; i < translationMap.length; i++) {
        const mapping = translationMap[i];

        // ×‘×“×™×§×” ××•×œ ×›×•×ª×¨×•×ª ×¢×‘×¨×™×•×ª - ×”×ª×××” ××“×•×™×§×ª
        for (let j = 0; j < mapping.hebrewHeaders.length; j++) {
            const hebrewHeader = mapping.hebrewHeaders[j].toLowerCase();
            if (text === hebrewHeader) {
                return {
                    fieldName: mapping.field,
                    originalHeader: originalHeader,
                    isUnknown: false
                };
            }
        }

        // ×‘×“×™×§×” ××•×œ ×›×•×ª×¨×•×ª ×× ×’×œ×™×•×ª - ×”×ª×××” ××“×•×™×§×ª
        for (let k = 0; k < mapping.englishHeaders.length; k++) {
            const englishHeader = mapping.englishHeaders[k].toLowerCase();
            if (text === englishHeader) {
                return {
                    fieldName: mapping.field,
                    originalHeader: originalHeader,
                    isUnknown: false
                };
            }
        }
    }

    // PASS 2: Try substring matches (lower priority, for partial matches)
    for (let i = 0; i < translationMap.length; i++) {
        const mapping = translationMap[i];

        // ×‘×“×™×§×” ××•×œ ×›×•×ª×¨×•×ª ×¢×‘×¨×™×•×ª - ×”×ª×××” ×—×œ×§×™×ª
        for (let j = 0; j < mapping.hebrewHeaders.length; j++) {
            const hebrewHeader = mapping.hebrewHeaders[j].toLowerCase();
            if (text.indexOf(hebrewHeader) >= 0) {
                return {
                    fieldName: mapping.field,
                    originalHeader: originalHeader,
                    isUnknown: false
                };
            }
        }

        // ×‘×“×™×§×” ××•×œ ×›×•×ª×¨×•×ª ×× ×’×œ×™×•×ª - ×”×ª×××” ×—×œ×§×™×ª
        for (let k = 0; k < mapping.englishHeaders.length; k++) {
            const englishHeader = mapping.englishHeaders[k].toLowerCase();
            if (text.indexOf(englishHeader) >= 0) {
                return {
                    fieldName: mapping.field,
                    originalHeader: originalHeader,
                    isUnknown: false
                };
            }
        }
    }

    // ×× ×œ× × ××¦××” ×”×ª×××” - ×”×—×–×¨ ×¢××•×“×” ×œ× ××–×•×”×”
    return {
        fieldName: 'UnknownColumn_' + colIndex,
        originalHeader: originalHeader,
        isUnknown: true
    };
}

function isRealItemRow(rowData) {
    const keys = Object.keys(rowData);

    if (keys.length < 2) {
        return false;
    }

    // âœ… ×ª××™×›×” ×‘×©××•×ª ×©×“×•×ª ×—×“×©×™× (TotalPrice) ×•×™×©× ×™× (Amount)
    const hasAmount = rowData.Amount !== undefined || rowData.TotalPrice !== undefined;
    const hasQuantity = rowData.Quantity !== undefined;
    const hasUnitPrice = rowData.UnitPrice !== undefined;

    // ×©×•×¨×” ×××™×ª×™×ª ×—×™×™×‘×ª ×œ×›×œ×•×œ ×œ×¤×—×•×ª ××—×“ ××”×©×“×•×ª ×”××¡×¤×¨×™×™×:
    // Amount/TotalPrice, Quantity, ××• UnitPrice
    // ×©×•×¨×•×ª ×¢× ×¨×§ ProductCode + Description ×”×Ÿ ×©×•×¨×•×ª ×”××©×š
    if (!hasAmount && !hasQuantity && !hasUnitPrice) {
        return false;
    }

    // ×× ×™×© Amount ××• TotalPrice ×‘×•×“×§ ×©×”×•× ×ª×§×™×Ÿ
    if (hasAmount) {
        const amount = rowData.Amount || rowData.TotalPrice;
        if (typeof amount === 'number' && amount > 0) {
            return true;
        }
    }

    // ×× ×™×© Quantity ××• UnitPrice - ×–×” ×¤×¨×™×˜ ×ª×§×™×Ÿ
    if (hasQuantity || hasUnitPrice) {
        return true;
    }

    return false;
}

function parseValue(value) {
    if (typeof value !== 'string') return value;
    
    const cleaned = value.replace(/,/g, '').trim();
    const numPattern = new RegExp('^[0-9]+\\.?[0-9]*$');
    
    if (numPattern.test(cleaned)) {
        const num = parseFloat(cleaned);
        if (!isNaN(num)) {
            return num;
        }
    }
    
    return value;
}

function detectNumbersByContext(content, existingFields) {
    const detected = {};
    
    if (!content) return detected;
    
    detectVendorAdditionalId(content, existingFields, detected);
    detectPhoneNumbers(content, existingFields, detected);
    detectTimes(content, existingFields, detected);
    detectDates(content, existingFields, detected);
    detectBankDetails(content, existingFields, detected);
    detectEmails(content, existingFields, detected);
    
    return detected;
}

function findAllNumbers(content, minLen, maxLen) {
    const numbers = [];
    const pattern = new RegExp('\\b(\\d{' + minLen + ',' + maxLen + '})\\b', 'g');
    const matches = content.match(pattern) || [];
    for (let i = 0; i < matches.length; i++) {
        numbers.push(matches[i]);
    }
    return numbers;
}

function detectVendorAdditionalId(content, existing, detected) {
    const companyIdx = content.indexOf('Company');
    if (companyIdx === -1) return;

    const afterCompany = content.substring(companyIdx);
    const numbers = findAllNumbers(afterCompany, 9, 10);

    if (numbers.length >= 2) {
        const first = numbers[0];
        const second = numbers[1];

        if (second !== first &&
            second !== existing.VendorTaxId &&
            second !== existing.CustomerTaxId) {
            detected.VendorAdditionalId = second;
        }
    }
}

function detectPhoneNumbers(content, existing, detected) {
    const phonePattern = new RegExp('[0-9]{2,3}[-\\s][0-9]{7,8}', 'g');
    const matches = content.match(phonePattern) || [];
    
    const usedNumbers = [];
    if (existing.VendorTaxId) usedNumbers.push(existing.VendorTaxId);
    if (existing.CustomerTaxId) usedNumbers.push(existing.CustomerTaxId);
    
    const phones = [];
    for (let i = 0; i < matches.length; i++) {
        const phone = matches[i];
        
        if (phone.indexOf('\n') >= 0 || phone.indexOf('\r') >= 0) {
            continue;
        }
        
        const cleanPhone = phone.replace(/[-\s]/g, '');
        
        let isUsed = false;
        for (let j = 0; j < usedNumbers.length; j++) {
            if (usedNumbers[j] === cleanPhone) {
                isUsed = true;
                break;
            }
        }
        
        if (!isUsed) {
            const position = content.indexOf(phone);
            phones.push({
                phone: phone,
                position: position,
                isVendor: position < content.length / 3
            });
        }
    }
    
    const vendorPhones = [];
    const customerPhones = [];
    
    for (let i = 0; i < phones.length; i++) {
        if (phones[i].isVendor) {
            vendorPhones.push(phones[i]);
        } else {
            customerPhones.push(phones[i]);
        }
    }
    
    if (vendorPhones.length > 0 && !existing.VendorTel) {
        detected.VendorTel = vendorPhones[0].phone;
    }
    if (vendorPhones.length > 1 && !existing.VendorFax) {
        detected.VendorFax = vendorPhones[1].phone;
    }
    if (customerPhones.length > 0 && !existing.CustomerTel) {
        detected.CustomerTel = customerPhones[0].phone;
    }
    if (customerPhones.length > 1 && !existing.CustomerFax) {
        detected.CustomerFax = customerPhones[1].phone;
    }
}

function detectTimes(content, existing, detected) {
    const timePattern = new RegExp('[0-9]{1,2}:[0-9]{2}(:[0-9]{2})?', 'g');
    const matches = content.match(timePattern) || [];
    
    if (matches.length > 0 && !existing.InvoiceTime) {
        detected.InvoiceTime = matches[0];
    }
    if (matches.length > 1 && !existing.PrintTime) {
        detected.PrintTime = matches[matches.length - 1];
    }
}

function detectDates(content, existing, detected) {
    const dates = [];
    
    const pattern1 = new RegExp('[0-9]{1,2}[./][0-9]{1,2}[./][0-9]{4}', 'g');
    const matches1 = content.match(pattern1) || [];
    for (let i = 0; i < matches1.length; i++) {
        const parsed = parseDateString(matches1[i]);
        if (parsed) {
            dates.push({
                date: parsed,
                position: content.indexOf(matches1[i])
            });
        }
    }
    
    dates.sort(function(a, b) { return a.position - b.position; });
    
    if (dates.length > 0 && !existing.InvoiceDate) {
        detected.InvoiceDate = dates[0].date;
    }
    if (dates.length > 1 && !existing.DueDate) {
        detected.DueDate = dates[dates.length - 1].date;
    }
}

function parseDateString(dateStr) {
    const parts1 = dateStr.match(/([0-9]{1,2})[./]([0-9]{1,2})[./]([0-9]{4})/);
    if (parts1) {
        const day = parts1[1].length === 1 ? '0' + parts1[1] : parts1[1];
        const month = parts1[2].length === 1 ? '0' + parts1[2] : parts1[2];
        return parts1[3] + '-' + month + '-' + day;
    }
    
    return null;
}

function detectBankDetails(content, existing, detected) {
    if (!existing.PaymentDetails_IBAN) {
        const ibanIdx = content.indexOf('IBAN');
        if (ibanIdx >= 0) {
            const afterIban = content.substring(ibanIdx);
            const ibanPattern = new RegExp('IL[0-9]{21}');
            const match = afterIban.match(ibanPattern);
            if (match) {
                detected.PaymentDetails_IBAN = match[0];
                
                const accountNum = match[0].substring(match[0].length - 6);
                if (!existing.PaymentDetails_AccountNumber) {
                    detected.PaymentDetails_AccountNumber = accountNum;
                }
            }
        }
    }
    
    if (!existing.PaymentDetails_SWIFT) {
        const swiftIdx = content.indexOf('SWIFT');
        if (swiftIdx >= 0) {
            const afterSwift = content.substring(swiftIdx);
            const swiftPattern = new RegExp('[A-Z0-9]{8,11}');
            const match = afterSwift.match(swiftPattern);
            if (match) {
                detected.PaymentDetails_SWIFT = match[0];
            }
        }
    }
}

function detectEmails(content, existing, detected) {
    const emailPattern = new RegExp('[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}', 'g');
    const matches = content.match(emailPattern) || [];
    
    for (let i = 0; i < matches.length; i++) {
        const email = matches[i];
        const position = content.indexOf(email);
        const isVendor = position < content.length / 3;
        
        if (isVendor && !existing.VendorEmail && !detected.VendorEmail) {
            detected.VendorEmail = email;
        } else if (!isVendor && !existing.CustomerEmail && !detected.CustomerEmail) {
            detected.CustomerEmail = email;
        }
    }
}

// ================================================================
// ×—×™×œ×•×¥ ×’× ×¨×™ ×©×œ ××™×“×¢ ×™×™×—×•×“×™
// ================================================================

function extractUniqueData(content, existingFields) {
    const uniqueData = [];
    const seen = {};

    // 1. ×–×•×’×•×ª "×ª×•×•×™×ª: ×¢×¨×š"
    const pairs = extractLabelValuePairs(content, existingFields);
    for (let i = 0; i < pairs.length; i++) {
        if (!seen[pairs[i].value]) {
            uniqueData.push(pairs[i]);
            seen[pairs[i].value] = true;

            // ×¡××Ÿ ×’× ××¡×¤×¨×™× ×©× ××¦××™× ×‘×ª×•×š ×”value ×›×“×™ ×œ×× ×•×¢ ×›×¤×™×œ×•×™×•×ª
            // ×œ×“×•×’××”: "1917035 (202857)" -> ×¡××Ÿ ×’× 1917035 ×•-202857
            const valueStr = String(pairs[i].value); // ×”××¨×” ×œ-string ×œ××§×¨×” ×©× ×¨××œ ×œ××¡×¤×¨
            const numbersInValue = valueStr.match(/\d{3,}/g) || [];
            for (let n = 0; n < numbersInValue.length; n++) {
                seen[numbersInValue[n]] = true;
            }
        }
    }

    // 2. ××¡×¤×¨×™ ×ª×¢×•×“×•×ª (BOOKNUM) ×œ×¤×™ ×”×§×©×¨ - ×–×™×”×•×™ ×¡×¤×¦×™×¤×™!
    const docNumbers = extractDocumentNumbers(content, existingFields);
    for (let i = 0; i < docNumbers.length; i++) {
        if (!seen[docNumbers[i].value]) {
            uniqueData.push(docNumbers[i]);
            seen[docNumbers[i].value] = true;
        }
    }

    // 3. ××¡×¤×¨×™× ×¢× ×¤×•×¨××˜ ××™×•×—×“ (××§×¤×™×, ×§×•×•×™× × ×˜×•×™×™×) - ×œ×¤× ×™ pure numbers!
    const formattedNumbers = extractFormattedNumbers(content, existingFields);
    for (let i = 0; i < formattedNumbers.length; i++) {
        if (!seen[formattedNumbers[i].value]) {
            uniqueData.push(formattedNumbers[i]);
            seen[formattedNumbers[i].value] = true;

            // ×¡××Ÿ ×’× ××ª ×”×—×œ×§×™× ×›×“×™ ×œ×× ×•×¢ ×›×¤×™×œ×•×™×•×ª (741-69-103 -> ×’× 741, 69, 103)
            const parts = formattedNumbers[i].value.split('-');
            for (let p = 0; p < parts.length; p++) {
                seen[parts[p]] = true;
            }
        }
    }

    // 4. ×›×œ ×”××¡×¤×¨×™× (6-12 ×¡×¤×¨×•×ª) - ××•× ×¢ ×‘×¨×§×•×“×™× ××¨×•×›×™× ×•××¡×¤×¨×™× ×§×¦×¨×™× ××“×™
    const pureNumbers = extractAllPureNumbers(content, existingFields, 6, 12);
    for (let i = 0; i < pureNumbers.length; i++) {
        if (!seen[pureNumbers[i].value]) {
            uniqueData.push(pureNumbers[i]);
            seen[pureNumbers[i].value] = true;
        }
    }

    // 5. ×›×œ ×”×§×•×“×™× ×”××œ×¤×-× ×•××¨×™×™× (×œ×¤×—×•×ª 5 ×ª×•×•×™×)
    const alphaCodes = extractAlphanumericCodes(content, existingFields, 5, 30);
    for (let i = 0; i < alphaCodes.length; i++) {
        if (!seen[alphaCodes[i].value]) {
            uniqueData.push(alphaCodes[i]);
            seen[alphaCodes[i].value] = true;
        }
    }

    return uniqueData;
}

function extractLabelValuePairs(content, existing) {
    const pairs = [];
    const lines = content.split('\n');

    // Pattern 1: "×ª×•×•×™×ª: ×¢×¨×š" ×‘××•×ª×” ×©×•×¨×” (×××¤×©×¨ ×›×œ ×ª×• ×‘label ×—×•×¥ ×-:)
    const labelValuePattern = /^([^:\n]{2,80}):\s*([^\n]+)$/;
    // Pattern 2: ×ª×•×•×™×ª ×¢× 2+ ×¨×•×•×—×™× ×•××– ×¢×¨×š
    const spacedPattern = /^([×-×ªA-Za-z\s\.]{2,20})\s{2,}([^\n]+)$/;
    // Pattern 3: ×ª×•×•×™×ª ×§×¦×¨×” (×¢×“ 3 ××™×œ×™×) + ×¨×•×•×— + ×¢×¨×š ××¡×¤×¨×™ - ×–×™×”×•×™ "××¡' ×ª×¢×•×“×” 12345678"
    const shortLabelNumericPattern = /^([×-×ªA-Za-z\s\.]{3,30})\s+(\d[\d\s\-\.,\(\)]+)$/;
    // âš ï¸ v2.16: ×‘×™×˜×•×œ currentSection - ×™×•×¦×¨ ×™×•×ª×¨ ×¨×¢×© ×××©×¨ ×¢×•×–×¨!
    // labels ×¦×¨×™×›×™× ×œ×”×™×•×ª standalone, ×œ×œ× ×©×™×œ×•×‘ ××¡×§×©× ×™×

    for (let i = 0; i < lines.length; i++) {
        const line = lines[i].trim();
        if (!line || line.length < 3) continue;

        // ×‘×“×•×§ "×ª×•×•×™×ª: ×¢×¨×š" ×‘×›×œ ×”×ª×‘× ×™×•×ª
        let match = line.match(labelValuePattern);
        if (!match) {
            match = line.match(spacedPattern);
        }
        if (!match) {
            // × ×¡×” ××ª ×”×ª×‘× ×™×ª ×”×—×“×©×” - ×ª×•×•×™×ª ×§×¦×¨×” + ×¢×¨×š ××¡×¤×¨×™
            match = line.match(shortLabelNumericPattern);
            // ××‘×œ ×¨×§ ×× ×”t×•×•×™×ª ×œ× ××›×™×œ×” ×™×•×ª×¨ ×-4 ××™×œ×™× (×œ×× ×•×¢ ×ª×¤×™×¡×ª ×©×•×¨×•×ª ×˜×‘×œ×”)
            if (match) {
                const wordCount = match[1].trim().split(/\s+/).length;
                if (wordCount > 4) {
                    match = null; // ×™×•×ª×¨ ××“×™ ××™×œ×™× - ×–×” ×œ× label
                }
            }
        }

        if (match) {
            let label = match[1].trim();
            let value = match[2].trim();

            // ×× ×”×¢×¨×š ×¨×™×§ ××• "×œ× ×¦×•×™×™×Ÿ" - ×“×œ×’
            if (!value || value === '(×œ× ×¦×•×™×™×Ÿ)' || value === '(×œ× ×¦×•×™× ×•)') {
                continue;
            }

            // âš ï¸ FIX v2.19: ×“×œ×’ ×¢×œ ×¢×¨×›×™× ××¨×•×›×™× ××“×™ (××©×¤×˜×™× ×©×œ××™×)
            // ×¢×¨×š ××¨×•×š ×-100 ×ª×•×•×™× = ×›× ×¨××” ××©×¤×˜ ××• ×˜×§×¡×˜ ××¨×•×š, ×œ× ××™×“×¢ ××–×”×”
            if (value.length > 100) {
                continue; // "×œ×ª×©×•××ª ×œ×‘×š: ×¨×™×©×™×•×Ÿ ×”×¨×›×‘ ×ª×§×£ ×¨×§ ×œ××—×¨ ×ª×©×œ×•×..." â† ××©×¤×˜!
            }

            // âœ… FIX v2.17: ×“×œ×’ ×¢×œ ×¢×¨×›×™× ×©×”× ×¨×¢×©
            // ×¢×¨×›×™× ×§×¦×¨×™× ××“×™ (1-2 ×ª×•×•×™×) ×›××• "=", ":", ×•×›×•'
            if (value.length <= 2 && !/^\d+$/.test(value)) {
                continue; // "=" â† ×¨×¢×©!
            }

            // ×“×œ×’ ×¢×œ ×¢×¨×›×™× ×©×”× ××˜×-×“××˜×”/×§×•×“
            const valueLower = value.toLowerCase();
            if (valueLower.includes('winsert') || valueLower.includes('@@@')) {
                continue; // "WINSERT:..." ××• "×‘×¢"× @@@" â† ××˜×-×“××˜×”!
            }

            // ×“×œ×’ ×¢×œ ×¢×¨×›×™× ×©× ×¨××™× ×›××• paths/emails ××‘×œ ×œ× ×“×•×"×œ ×œ×’×™×˜×™××™
            if (value.includes('@') && value.split(':').length > 2) {
                continue; // "a240210:120825:C:SI25003642:Account2@t-p-y.co.il" â† ×§×•×“!
            }

            // âš ï¸ FIX v2.20: ×“×œ×’ ×¢×œ OCR artifacts
            // ":selected:", ":unselected:" ×•×›×•' = ×¨×¢×© ×-OCR
            if (value.includes(':selected:') || value.includes(':unselected:')) {
                continue; // ":selected:" ××• "...www.site.com:selected::selected:" â† OCR!
            }

            // âœ… FIX v2.15: ×“×œ×’ ×¢×œ values ×©×”× ×¨×©×™××•×ª (××›×™×œ×•×ª ×¤×¡×™×§×™× ××¨×•×‘×™×)
            if (isList(value)) {
                continue; // "×˜×œ×¤×•×Ÿ: 04-6445585, ×¤×§×¡: 1534-6438399" â† ×¨×©×™××”!
            }

            // âœ… × ×§×” ××ª ×”label ××ª×•×•×™× ××™×•×ª×¨×™×
            label = cleanHeader(label);

            // ×“×œ×’ ×¢×œ labels ×©×”× ×¨×§ ××¡×¤×¨×™× ××• ×§×¦×¨×™× ××“×™
            if (label.length < 2 || /^\d+$/.test(label)) {
                continue;
            }

            // âš ï¸ FIX v2.19: ×“×œ×’ ×¢×œ labels ××¨×•×›×™× ××“×™ (3+ ××™×œ×™×)
            // label ×¢× 3 ××™×œ×™× ××• ×™×•×ª×¨ = ×œ× label ×××™×ª×™ (×›× ×¨××” ×—×œ×§ ×××©×¤×˜)
            const wordCount = label.split(/\s+/).filter(w => w.length > 0).length;
            if (wordCount >= 3) {
                continue; // "×œ×ª×©×•××ª ×œ×‘×š" â† 2 ××™×œ×™× = ×‘×¡×“×¨, ××‘×œ 3+ = ×œ× label!
            }

            // âœ… FIX v2.15: ×“×œ×’ ×¢×œ ×©×•×¨×•×ª ×©× ×¨××•×ª ×›××• ×—×œ×§ ××˜×‘×œ×”
            // (××›×™×œ×•×ª "×¡×”"×›", "×”× ×—×”", "total", "discount", ××—×•×–×™×)
            const labelLower = label.toLowerCase();
            if (labelLower.includes('×¡×”"×›') || labelLower.includes('×¡×”×´×›') ||
                labelLower.includes('×”× ×—×”') || labelLower.includes('discount') ||
                labelLower.includes('total') || label.includes('%') ||
                labelLower.includes('×œ×ª×©×œ×•×')) {
                continue;
            }

            // âš ï¸ v2.16: ×‘×™×˜×•×œ currentSection - labels ×”× standalone!

            // âœ¨ × ×¨××•×œ ×”×¢×¨×š ×œ×¤× ×™ ×©××™×¨×”
            let normalizedValue = value;

            // ×–×™×”×•×™ ×•×”×¡×¨×ª ××˜×‘×¢
            const currency = detectCurrencyInValue(value);
            if (currency) {
                normalizedValue = removeCurrency(normalizedValue, currency);
            }

            // × ×¨××•×œ ××—×•×–×™×
            if (isPercentageField(label)) {
                normalizedValue = cleanPercentage(normalizedValue);
            }
            // × ×™×¡×™×•×Ÿ ×”××¨×” ×œ××¡×¤×¨
            else {
                const asNumber = cleanNumber(normalizedValue);
                if (asNumber !== normalizedValue) {
                    normalizedValue = asNumber;
                } else {
                    // × ×™×¡×™×•×Ÿ ×”××¨×” ×œ×ª××¨×™×š
                    const asDate = normalizeDate(normalizedValue);
                    if (asDate !== normalizedValue) {
                        normalizedValue = asDate;
                    }
                }
            }

            // âš ï¸ FIX v2.20: ×“×œ×’ ×¢×œ labels ×©×œ ××™×œ×” ×‘×•×“×“×ª ×¢× ×¢×¨×š ××¡×¤×¨×™ ×§×¦×¨
            // "since: 1947" â† ××™×œ×” ×‘×•×“×“×ª + 4 ×¡×¤×¨×•×ª = ×œ× ×¨×œ×•×•× ×˜×™!
            if (wordCount === 1 && typeof normalizedValue === 'number' && normalizedValue < 100000) {
                continue; // ×©× ×™×, ××¡×¤×¨×™× ×§×¦×¨×™× ×•×›×•'
            }

            if (!isValueExists(normalizedValue, existing) && !isCommonLabel(label)) {
                pairs.push({label: label, value: normalizedValue});
            }
        }
    }
    return pairs;
}

function extractFormattedNumbers(content, existing) {
    const numbers = [];

    // ×–×™×”×•×™ ××¡×¤×¨×™× ×¢× ××§×¤×™× (×›××• ××¡×¤×¨ ×¨×™×©×•×™: 741-69-103)
    // ××—×¤×© ×œ×¤×—×•×ª 2 ×—×œ×§×™× ××¡×¤×¨×™×™× ×¢× ××§×£ ×‘×™× ×™×”×
    const hyphenPattern = /\b(\d{1,4}-\d{1,4}(?:-\d{1,4})*)\b/g;
    const matches = content.match(hyphenPattern) || [];

    for (let i = 0; i < matches.length; i++) {
        const num = matches[i];

        // ×“×œ×’ ×¢×œ ×ª××¨×™×›×™× (DD/MM/YY ××• DD-MM-YY)
        if (/^\d{1,2}[-\/]\d{1,2}[-\/]\d{2,4}$/.test(num)) {
            continue;
        }

        // âš ï¸ FIX v2.19: ×“×œ×’ ×¢×œ ××¡×¤×¨×™× ×§×¦×¨×™× ××“×™ ×¢× ××§×¤×™×
        // ××¡×¤×¨ ×¢× ××§×£ ×©××•×¨×›×• ×”×›×•×œ×œ < 6 ×ª×•×•×™× (×›×•×œ×œ ××§×¤×™×) = ×›× ×¨××” ×œ× ×¨×œ×•×•× ×˜×™
        if (num.length < 6) {
            continue; // "26-9" (4 ×ª×•×•×™×) â† ×œ× ×¨×œ×•×•× ×˜×™!
        }

        // ×“×œ×’ ×× ×™×© ×—×œ×§ ×§×¦×¨ ××“×™ (< 2 ×¡×¤×¨×•×ª)
        const parts = num.split('-');
        let hasShortPart = false;
        for (let p = 0; p < parts.length; p++) {
            if (parts[p].length < 2) {
                hasShortPart = true;
                break;
            }
        }
        if (hasShortPart) {
            continue; // "765-0021" ×¢× "0021" â†’ ××•×œ×™ ×‘×¡×“×¨, ××‘×œ "26-9" ×¢× "9" â†’ ×œ× ×‘×¡×“×¨!
        }

        // ×“×œ×’ ×× ×›×‘×¨ ×§×™×™× ×‘×©×“×•×ª ××—×¨×™×
        if (!isValueExists(num, existing)) {
            numbers.push({label: '××¡×¤×¨', value: num});
        }
    }

    return numbers;
}

function extractAllPureNumbers(content, existing, minLen, maxLen) {
    const numbers = [];

    // ×©×™××•×© ×‘×¤×˜×¨×Ÿ ×¢× negative lookbehind/lookahead ×œ×× ×•×¢ ×ª×¤×™×¡×ª ×—×œ×§×™× ×××—×™×¨×™× ×•×§×•×“×™×
    // ×œ× ×œ×ª×¤×•×¡ ××¡×¤×¨×™× ×©×œ×¤× ×™×”× ××• ××—×¨×™×”× ×™×©: × ×§×•×“×”, ×¤×¡×™×§, ×¡×¤×¨×”, ××•×ª, ××§×£, ×¤×œ×•×¡, ××• pipe
    // ×›×š × ×× ×¢ ××œ×ª×¤×•×¡ "256" ×-"SI256SP005599" ××• "3600" ×-"13.3600" ××• "972-4" ×-"+972-4-9111442+"
    const pattern = new RegExp('(?<![.,\\-+|\\dA-Za-z])(\\d{' + minLen + ',' + maxLen + '})(?![.,\\-+|\\dA-Za-z])', 'g');

    let match;
    while ((match = pattern.exec(content)) !== null) {
        const num = match[1];

        // âš ï¸ FIX v2.20: ×“×œ×’ ×¢×œ ××¡×¤×¨×™× ×©× ×¨××™× ×›××• ×˜×œ×¤×•× ×™×
        // ×˜×œ×¤×•×Ÿ = 9-10 ×¡×¤×¨×•×ª ×©××ª×—×™×œ×•×ª ×‘-0 (× ×™×™×“×™× = 9, ×§×•×•×™×™× = 10)
        if ((num.length === 9 || num.length === 10) && num.startsWith('0')) {
            continue; // "528553984", "0506371401" â† ×˜×œ×¤×•× ×™×!
        }

        if (!isValueExists(num, existing)) {
            numbers.push({label: '××¡×¤×¨', value: num});
        }
    }

    return numbers;
}

function extractAlphanumericCodes(content, existing, minLen, maxLen) {
    const codes = [];

    // âš ï¸ FIX v2.19: ×”×’×‘×œ ××•×¨×š ××§×¡×™××œ×™ ×œ-15 (×œ× ××¨×•×š ××“×™)
    const actualMaxLen = Math.min(maxLen, 15);
    const pattern = new RegExp('\\b([A-Za-z0-9]{' + minLen + ',' + actualMaxLen + '})\\b', 'g');

    let match;
    while ((match = pattern.exec(content)) !== null) {
        const code = match[1];
        const matchIndex = match.index;

        // ×—×™×™×‘ ×œ×”×›×™×œ ×’× ××•×ª×™×•×ª ×•×’× ×¡×¤×¨×•×ª
        if (!/[A-Za-z]/.test(code) || !/\d/.test(code)) {
            continue;
        }

        // âš ï¸ FIX v2.19: ×“×œ×’ ×¢×œ ×§×•×“×™× ×©×”× ×—×œ×§ ××§×•×“ ××¨×•×š ×™×•×ª×¨
        // ×‘×“×•×§ ×× ×™×© "/" ××• "-" ×œ×¤× ×™/××—×¨×™ ×”×§×•×“ (boundary ×‘×¢×™×™×ª×™)
        const charBefore = matchIndex > 0 ? content[matchIndex - 1] : '';
        const charAfter = matchIndex + code.length < content.length ? content[matchIndex + code.length] : '';

        // ×× ×™×© "/" ××• "-" ×××© ×œ×¤× ×™ ××• ××—×¨×™ = ×–×” ×—×œ×§ ××§×•×“ ××¨×•×š ×™×•×ª×¨
        if (charBefore === '/' || charBefore === '-' || charAfter === '/' || charAfter === '-') {
            continue; // "65R17" ×-"175/65R17" ××• "KGB70L" ×-"KGB70L-AHXNKW" â† ×—×œ×§×™ ×§×•×“!
        }

        // âœ… FIX v2.18: ×“×œ×’ ×¢×œ "×§×•×“×™×" ×©×”× ×‘×¢×™×§×¨ ××•×ª×™×•×ª (×›××• "Invoice4U")
        // ×§×•×“ ×××™×ª×™ = ×œ×¤×—×•×ª 30% ×¡×¤×¨×•×ª
        const digitCount = (code.match(/\d/g) || []).length;
        const digitRatio = digitCount / code.length;
        if (digitRatio < 0.3) {
            continue; // "Invoice4U" â†’ 1/9 = 11% ×¡×¤×¨×•×ª â† ×œ× ×§×•×“!
        }

        // âœ… FIX v2.15: ×“×œ×’ ×¢×œ ×§×•×“×™× ×©×›×‘×¨ ×§×™×™××™× ×‘×©×“×•×ª ××—×¨×™×
        if (isValueExists(code, existing)) {
            continue;
        }

        // âœ… FIX v2.15: ×“×œ×’ ×¢×œ ×§×•×“×™× ×©× ×¨××™× ×›××• ××§"×˜ ×œ×§×•×— ××˜×‘×œ×”
        // ×“×¤×•×¡ × ×¤×•×¥: ××•×ª ××—×ª + 6-8 ×¡×¤×¨×•×ª (r5273535, SO25000145)
        // ××‘×œ ×× ×–×” ×§×•×“ ××¨×•×š ×¢× ××•×ª×™×•×ª ×•××¡×¤×¨×™× ××¢×•×¨×‘×‘×™× - ×–×” ×‘×¡×“×¨
        const singleLetterPattern = /^[a-zA-Z]{1,2}\d{6,8}$/;
        if (singleLetterPattern.test(code)) {
            // ×–×” × ×¨××” ×›××• ××§"×˜ ×œ×§×•×— - ×“×œ×’
            continue;
        }

        codes.push({label: '×§×•×“', value: code});
    }

    return codes;
}

/**
 * ×–×™×”×•×™ ×¡×¤×¦×™×¤×™ ×©×œ ××¡×¤×¨×™ ×ª×¢×•×“×•×ª (BOOKNUM) ×œ×¤×™ ×”×§×©×¨
 * ××—×¤×© ××¡×¤×¨×™× (6-10 ×¡×¤×¨×•×ª) ×‘×¡×‘×™×‘×” ×©×œ ××™×œ×•×ª ××¤×ª×— ×›××• "×ª×¢×•×“×”", "××¡×³ ×ª×¢×•×“×”", ×•×›×•×³
 */
function extractDocumentNumbers(content, existing) {
    const docNumbers = [];
    const lines = content.split('\n');

    // ××™×œ×•×ª ××¤×ª×— ×©××¡×× ×•×ª ×ª×¢×•×“×•×ª
    const docKeywords = [
        '×ª×¢×•×“×”', '×ª×¢×•×“', "××¡' ×ª×¢×•×“×”", "××¡×³ ×ª×¢×•×“×”", '××¡×¤×¨ ×ª×¢×•×“×”',
        'document', 'doc number', 'doc no', 'doc#', 'document number',
        'delivery note', '×ª.××©×œ×•×—', '×ª. ××©×œ×•×—', '×ª×¢×•×“×ª ××©×œ×•×—',
        'receipt', '×§×‘×œ×”', '××¡×³ ×§×‘×œ×”', '××¡×¤×¨ ×§×‘×œ×”'
    ];

    for (let i = 0; i < lines.length; i++) {
        const line = lines[i];
        const lineLower = line.toLowerCase();

        // ×‘×“×•×§ ×× ×‘×©×•×¨×” ×™×© ××™×œ×ª ××¤×ª×— ×©×œ ×ª×¢×•×“×”
        let hasDocKeyword = false;
        for (let k = 0; k < docKeywords.length; k++) {
            if (lineLower.includes(docKeywords[k].toLowerCase())) {
                hasDocKeyword = true;
                break;
            }
        }

        if (!hasDocKeyword) continue;

        // ×—×¤×© ××¡×¤×¨×™× ×‘×©×•×¨×” (6-10 ×¡×¤×¨×•×ª)
        const numberPattern = /\b(\d{6,10})\b/g;
        let match;
        while ((match = numberPattern.exec(line)) !== null) {
            const num = match[1];

            // ×“×œ×’ ×× ×”××¡×¤×¨ ×›×‘×¨ ×§×™×™× ×‘×©×“×•×ª ××—×¨×™×
            if (!isValueExists(num, existing)) {
                // × ×¡×” ×œ×–×”×•×ª ××ª ×”label ×”××“×•×™×§
                let label = '××¡×³ ×ª×¢×•×“×”';

                // ×× ×™×© ":" ×œ×¤× ×™ ×”××¡×¤×¨, ×§×— ××ª ××” ×©×œ×¤× ×™ ×”-":"
                const beforeNumber = line.substring(0, match.index);
                const colonMatch = beforeNumber.match(/([^\n:]{3,30}):\s*$/);
                if (colonMatch) {
                    label = colonMatch[1].trim();
                }
                // ×× ××™×Ÿ ":", × ×¡×” ×œ××¦×•× ××™×œ×ª ××¤×ª×— ×¡××•×›×”
                else {
                    for (let k = 0; k < docKeywords.length; k++) {
                        const keyword = docKeywords[k];
                        const keywordIndex = lineLower.lastIndexOf(keyword.toLowerCase(), match.index);
                        if (keywordIndex >= 0 && match.index - keywordIndex < 40) {
                            label = keyword;
                            break;
                        }
                    }
                }

                docNumbers.push({label: label, value: num});
            }
        }
    }

    return docNumbers;
}

function normalizeValue(value) {
    // Remove special characters (hyphens, spaces, dots, parentheses, colons)
    return value.toString().replace(/[-\s.():]/g, '').toLowerCase();
}

function isValueExists(value, existing) {
    const valueStr = value.toString().toLowerCase();
    const normalizedValue = normalizeValue(value);

    // Skip very short values (less than 3 chars) as they create too many false positives
    if (normalizedValue.length < 3) {
        return false;
    }

    for (const key in existing) {
        const fieldValue = existing[key];

        if (typeof fieldValue === 'string') {
            const fieldStr = fieldValue.toLowerCase();
            const normalizedField = normalizeValue(fieldValue);

            // Exact match (before normalization)
            if (fieldStr === valueStr) {
                return true;
            }

            // Check if value is part of field (after normalization)
            if (normalizedField.includes(normalizedValue)) {
                // If it's a prefix or suffix, filter it out (e.g., "052" in "052-5457201")
                if (normalizedField.startsWith(normalizedValue) || normalizedField.endsWith(normalizedValue)) {
                    return true;
                }

                // If it's in the middle, only filter if it's a significant portion (50%+)
                // This prevents "256" from being filtered just because it's in "SI256SP005599"
                const lengthRatio = normalizedValue.length / normalizedField.length;
                if (lengthRatio >= 0.5) {
                    return true;
                }
            }
        } else if (typeof fieldValue === 'number') {
            if (fieldValue.toString() === valueStr) {
                return true;
            }
        } else if (Array.isArray(fieldValue)) {
            for (let i = 0; i < fieldValue.length; i++) {
                const item = fieldValue[i];
                if (typeof item === 'string') {
                    const itemStr = item.toLowerCase();
                    const normalizedItem = normalizeValue(item);

                    if (itemStr === valueStr) {
                        return true;
                    }

                    if (normalizedItem.includes(normalizedValue)) {
                        if (normalizedItem.startsWith(normalizedValue) || normalizedItem.endsWith(normalizedValue)) {
                            return true;
                        }
                        const lengthRatio = normalizedValue.length / normalizedItem.length;
                        if (lengthRatio >= 0.5) {
                            return true;
                        }
                    }
                }
                if (typeof item === 'object') {
                    if (isValueExists(value, item)) {
                        return true;
                    }
                }
            }
        } else if (typeof fieldValue === 'object' && fieldValue !== null) {
            if (isValueExists(value, fieldValue)) {
                return true;
            }
        }
    }
    return false;
}

function isCommonLabel(label) {
    const common = [
        'total', 'sum', '×¡×š', '×¡×›×•×', 'page', '×¢××•×“',
        'date', '×ª××¨×™×š', 'amount', '×›××•×ª', 'price', '××—×™×¨'
    ];

    const labelLower = label.toLowerCase();
    return common.some(function(keyword) {
        return labelLower.indexOf(keyword) >= 0;
    });
}

function buildStructure(fields, columnMap) {
    const structure = {
        docType: "string",
        fields: {}
    };

    for (const fieldName in fields) {
        const fieldValue = fields[fieldName];
        if (fieldName === 'Items') {
            structure.Items = buildItemsStructure(fieldValue, columnMap);
        }
        else if (fieldName === 'UnidentifiedNumbers') {
            structure.fields.UnidentifiedNumbers = ["object"];
        }
        else if (Array.isArray(fieldValue)) {
            structure.fields[fieldName] = ["string"];
        }
        else {
            structure.fields[fieldName] = getFieldType(fieldName, fieldValue);
        }
    }

    return structure;
}

/**
 * ×‘×•× ×” ××™×¤×•×™ ×‘×™×Ÿ ×©×“×•×ª Azure (Amount_amount) ×œ×›×•×ª×¨×•×ª ××§×•×¨×™×•×ª
 * ×¢×œ ×™×“×™ ×”×ª×××” ×œ×¤×™ ×œ×•×’×™×§×” - Amount_amount/TotalPrice â†’ "×¡×”"×› ××—×™×¨"
 */
function buildAzureFieldToHeaderMap(columnMap) {
    const azureToOriginal = {};

    if (!columnMap || typeof columnMap !== 'object') {
        return azureToOriginal;
    }

    // ××™×¤×•×™ ×™×“×•×¢ ××¨××©: ×©×“×•×ª Azure â† ×©×“×•×ª ×—×“×©×™×
    const knownMapping = {
        'Amount_amount': 'TotalPrice',
        'Amount_currency': 'TotalPrice',
        'UnitPrice_amount': 'UnitPrice',
        'UnitPrice_currency': 'UnitPrice',
        'Discount': 'Discount',
        'ProductCode': 'ProductCode',
        'Description': 'Description',
        'Quantity': 'Quantity',
        'Unit': 'Unit'
    };

    // ×‘× ×” ××™×¤×•×™ ××”columnMap
    for (const colIndex in columnMap) {
        const colInfo = columnMap[colIndex];
        const newFieldName = colInfo.fieldName;
        const originalHeader = colInfo.originalHeader;

        // ××¦× ××ª ×©× ×”×©×“×” ×‘-Azure ×©××ª××™× ×œ×©×“×” ×”×—×“×©
        for (const azureField in knownMapping) {
            if (knownMapping[azureField] === newFieldName) {
                azureToOriginal[azureField] = originalHeader;
            }
        }
    }

    return azureToOriginal;
}

function buildItemsStructure(items, columnMap) {
    if (!items || items.length === 0) {
        return [];
    }

    const itemStructure = {};
    const firstItem = items[0];

    // ×‘× ×” ××™×¤×•×™ ××©×“×•×ª Azure ×œ×›×•×ª×¨×•×ª ××§×•×¨×™×•×ª
    const azureToOriginal = buildAzureFieldToHeaderMap(columnMap);

    // ×‘× ×™×™×ª structure ××•×¨×—×‘ ×¢× originalHeader
    for (const fieldName in firstItem) {
        const fieldValue = firstItem[fieldName];
        const fieldType = getFieldType(fieldName, fieldValue);

        // ×—×¤×© ××ª originalHeader - ×ª×—×™×œ×” ×‘××™×¤×•×™ Azure, ××—×¨ ×›×š ×‘××¤×ª ×”×¢××•×“×•×ª
        let originalHeader = '';

        // ×‘×“×•×§ ×× ×–×” ×©×“×” ×-Azure (Amount_amount, ×•×›×•')
        if (azureToOriginal[fieldName]) {
            originalHeader = azureToOriginal[fieldName];
        } else if (columnMap && typeof columnMap === 'object') {
            // ×–×” ×©×“×” ××”×˜×‘×œ×” - ×—×¤×© ×‘columnMap
            for (const colIndex in columnMap) {
                const colInfo = columnMap[colIndex];
                if (colInfo.fieldName === fieldName) {
                    originalHeader = colInfo.originalHeader;
                    break;
                }
            }
        }

        // ×‘× ×” ××•×‘×™×™×§×˜ ××•×¨×—×‘ ×œ×›×œ ×©×“×”
        itemStructure[fieldName] = {
            type: fieldType,
            originalHeader: originalHeader || fieldName
        };
    }

    return [itemStructure];
}

function getFieldType(fieldName, fieldValue) {
    if (fieldName.indexOf('Date') >= 0) return "YYYY-MM-DD";
    if (fieldName.indexOf('Time') >= 0) return "HH:MM:SS";
    if (fieldName.indexOf('_amount') >= 0) return "number";
    if (fieldName.indexOf('_currency') >= 0) return "string";
    if (typeof fieldValue === 'number') return "number";
    return "string";
}

function buildData(result) {
    return {
        docType: result.docType,
        fields: result.fields
    };
}

// ×”×¨×¥ ××ª ×”×¤×•× ×§×¦×™×” ×•×”×—×–×¨ ×ª×•×¦××”
const finalResult = processAzureInvoice(azureJsonInput);

finalResult.status = 'success';

// Export for require() compatibility
if (typeof module !== 'undefined' && module.exports) {
    module.exports = finalResult;
}

return finalResult;
